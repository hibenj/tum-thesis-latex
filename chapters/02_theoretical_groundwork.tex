\chapter{Preliminaries}\label{chapter:Preliminaries}
This chapter establishes a theoretical basis consisting of declarations and definitions required for the understanding of the ideas and their implementations proposed in this work. The three fields forming this basis are the representation of Logic Circuits, QCA technology and the placement and routing problem.

\section{Representation of Logic Circuits}
Logic Circuits provide a powerful construct that allows an abstraction of digital circuits to a logic level and thereby makes it possible to discuss and argue about them scientifically. This abstraction was made possible by the Boolean algebra, formed by the mathematician George Boole in 1847. It shows that every digital circuit can be represented by logic functions, independent of their underlying technology. In the following sections first, a definition of a Boolean algebra is given, and second, it is shown how logic networks can be formed using them.

\subsection{Boolean Functions}\label{subsec:boolfunc}
A definition of Boolean calculus was first provided by Edward V. Huntington in 1993. From \textit{set of independent postulates for the algebra of logic} and his own correction \cite{HuntingtonPostulate, HuntingtonCorrection}, the following equations form the basis of every Boolean algebra:

\begin{definition}[Basis for Boolean algebra]\label{Def:BasBool}
	Let $a, b, c$ be arbitrary elements of an abstract algebra $(L, +, ')$ with their set denoted as $B_{abc}$. The algebra includes the binary function disjunction $+ : B_{abc} \times B_{abc} \rightarrow B_{abc}$ and the unary function $' : B_{abc} \rightarrow B_{abc}$.
	\begin{table}[h]
		\centering
		\begin{tabular}{c}
			$a + b = b + a$ \\
			$(a + b) + c =  a + (b + c)$\\
			$(a' + b')' + (a' + b)' = a$\\
		\end{tabular}
	\end{table}
	
	The last of his postulates is named after the inventor and is commonly known as \textit{Huntington equation}. There also exists an "universe element" $u \in B_{abc}$ for which holds:
	
	\begin{table}[h]
		\centering
		\begin{tabular}{l}
			$\exists u' : a + u' = a$ \\
			$\exists u : a + a' = u$. \\
		\end{tabular}
	\end{table}
	
\end{definition}

Even though the two operands disjunction and negation function are powerful enough to form a Boolean algebra, the most common definition also uses the conjunction function $\cdot : B_{abc} \times B_{abc} \rightarrow B_{abc}$ in order to form shorter and more readable logic terms.
The most common Boolean algebra $\mathbb{B}$ is defined by the tuple $(B_{abc}, \vee, \wedge, \neg)$, where $\vee$ and $\wedge$ are other denotations for binary operands for disjunction $+$ and conjunction $\cdot$ in $\mathbb{B}$. The third function $\neg$ describes the unary negation function, which was previously denoted as $'$. The set $B_{abc}$ contains exactly two distinct elements $\{0, 1\}$, with $u=1$ and $\neg u = 0$ respectively \cite{Boolean_def}.\\

Since this definition is restricting the use of only the three Boolean functions $(\vee, \wedge, \neg)$, we want to extend it by the following definition \cite{muti_output_boolean_function}:

\begin{definition}[Boolean function]
	A Boolean function can be described as f: $\{0, 1\}^k \to \{0, 1\}$, with $k \in \mathbb{N}^*$ being the number of arguments or arity of the function. A function with $k$ arguments is referred to as $k$-ary. Multi-output Boolean functions can be described as $\{0, 1\}^k \to \{0, 1\}^m$, with $k \in \mathbb{N}^*$ and the integer $m > 0$.
\end{definition}

Nonetheless, every $k$-ary function can still be decomposed into a set of common Boolean functions $(\vee, \wedge, \neg )$.
Common notations for Boolean functions are \textit{conjunctive normal form} (CNF) or \textit{disjunctive normal form} (DNF), using literals.

\begin{definition}
	A literal is either an atom $a$ (positive literal) or the negation of an atom $\neg a$ (negative literal).
\end{definition}

\begin{definition}
	A propositional Boolean formula is said to be in CNF if it is a conjunction of \textit{clauses}, each of which is a disjunction of literals \cite{CNF}:\\
	\[\displaystyle\bigwedge_{i} \displaystyle\bigvee_{j} (\neg) v_{ij}, \]
	where $v_{ij} \in \mathbb{B}$.\\
	A propositional Boolean formula is said to be in DNF if it is a disjunction of clauses, each of which is a conjunction of literals:\\
	\[ \displaystyle\bigvee_{i} \displaystyle\bigwedge_{j} (\neg) v_{ij}, \]
	where $v_{ij} \in \mathbb{B}$.
	
\end{definition}

Using the CNF or rather the DNF, definition \ref{Def:BasBool} and \textit{De Morgan's laws} \cite{DeMorgans_laws}

\begin{definition}
	Given a Boolean Algebra $\mathbb{B} = (B_{ab}, \vee, \wedge, \neg)$ with two arbitrary elements $a,b \in B_{ab} = {0, 1}$, the following logic principles can be applied:
	\begin{table}[h]
		\centering
		\begin{tabular}{c}
			$\neg a \wedge \neg b = \neg (b \vee a)$ \\
			$\neg a \vee \neg b = \neg (b \wedge a)$,
		\end{tabular}
	\end{table}
\end{definition}

it follows that any Boolean algebra can be reduced to only two operands, e.g., conjunction ($\vee$) and negation ($\neg$) or disjunction ($\wedge$) and negation ($\neg$). Any set of such two Boolean functions is called \textit{universal}.

\subsection{Logic Networks}

There are many ways of representing Boolean Functions. But most of them, including, e.g. truth tables or reduced sum of products, suffer from exponential representations, making them impractical for big logic circuits. Even if a reasonable representation exists for a given function, simple operations like forming the complementary could yield an exponential function representation. Logic networks overcome these restrictions and have proven to be very useful in transforming logic circuits into gate representations. This process is also called \textit{logic synthesis}. An approach to logic networks is given in \cite{LogicNetwork}, describing \textit{function graphs} as binary decision diagram (BDD):

\begin{definition}[Function graph as BDD]
	A function graph is a rooted, directed graph with vertex set $V$ containing two types of vertices. A \textit{non-terminal} vertex $v$ has as attributes an argument index $index(v) \in \{1, . . .,n\}$, and two children $low(v),high(v) \in V$. A \textit{terminal} vertex v has as attribute a value $value(v)\in\{0,1\}$.\\
	\\
	Furthermore, for any non-terminal vertex $v$, if $low(v)$ is also non-terminal, then we must have
	$index(v) < index(low(v))$. Similarly, if $high(v)$ is non-terminal, then we must have
	$index(v) < index(high(v))$.
\end{definition}

\begin{definition}[Function Graph Boolean Functions]
	A function graph $G$ having root vertex $v$ denotes a function $f_v$ defined recursively as:
	\begin{enumerate}
		\item If v is a terminal vertex:
		\begin{enumerate}
			\item If $value(v)=1$, then $f_v=1$
			\item If $value(v)=0$, then $f_v=0$
		\end{enumerate}
		\item If $v$ is a non-terminal vertex with $index(v)=i$, then $f_v$ is the function \\ 
		$f_v(x_1, ..., x_n) = \bar{x}_i \cdot f_{low(v)}(x_1, ..., x_n) + x_i \cdot f_{high(v)}(x_1, ..., x_n)$.
	\end{enumerate}
\end{definition}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance={2cm and 2cm}, thick, main/.style = {draw, circle}] 
		\node[main] (1) at (0,0) [label=west:$v_1$]{$I_1$}; 
		\node[main] (2) at (0,-2)[label=west:$v_2$] {$I_2$};
		\node[main] (3) at (0,-4)[label=west:$v_3$] {$I_3$};
		\node[main] (4) at (0,-6)[label=west:$v_4$] {$I_4$}; 
		
		\node[main] (5) at (2,-1)[label=north:$v_5$]{$\wedge$}; 
		\node[main] (6) at (2,-5)[label=north:$v_6$]{$\vee$};
		
		\node[main] (7) at (4,-3)[label=north:$v_7$]{$\vee$};
	
		\node [right of = 7] (f) {$f_v$};
		
		
		\draw[->] (1) -- (5);
		\draw[->] (2) -- (5);
		\draw[->] (3) -- (6);
		\draw[->] (4) -- (6);
		\draw[->] (5) -- (7);
		\draw[->] (6) -- (7);
		\draw[->] (7) -- (f);
		
	\end{tikzpicture} 
	\\
	\hfill \break
	The corresponding recursive Boolean function reads:\\
	\hfill \break
	\begin{tabular}{l l}
		
		$f_v = f_v(v_7)$ &  $f_v(v_6) = f_v(v_3) \wedge f_v(v_4)$\\
		$f_v(v_7) = f_v(v_5) \vee f_v(v_6)$ &  $f_v(v_5) = f_v(v_1) \vee f_v(v_2)$\\
		&\\
		with primary inputs: & 	$f_v(v_1), f_v(v_2), f_v(v_3), f_v(v_4) \in \{0, 1\}$\\
		&\\
	\end{tabular}
	
	\caption{Binary Logic Network} \label{fig:LNEx}
\end{figure}

Since the definition reduces the number of children connected to a vertex to two, therefore only  allowing binary Boolean Functions, a custom definition is given:

\begin{definition}[Logic Network]
	A logic network $N(V, E)$ is a rooted, directed graph with vertex set $V$ and edge set $E$. For any vertex $v \in V$, vertices connected by incoming edges $e_{inc} \in E$ are called children. A vertex connected by an outgoing edge $e_{out} \in E$ is called parent.
	$V$ contains two types of vertices. A \textit{non-terminal} vertex $v$ has as attributes an argument index $index(v) \in \{1, . . .,n\}$, and $l$ children $child_1(v), ..., child_l(v) \in V$. 
	A \textit{terminal} vertex v has as attribute a value $value(v)\in\{0,1\}$.\\
	\\
	Furthermore, for any non-terminal vertex $v$, if $child_i(v)$ with $ 1 \leq i \leq l$, then we must have $index(child_i(v)) < index(v)$ respectively.
\end{definition}

\begin{definition}[Logic Network Boolean Functions]
	A set of $n$-ary Boolean Functions $x_1, ..., x_n \in \mathbb{B}$ is assigned to every vertex via the argument index $index(v) = i$. The graph function $f_v$ is defined recursively as:
	\begin{enumerate}
		\item If v is a terminal vertex:
		\begin{enumerate}
			\item If $value(v)=1$, then $f_v=1$
			\item If $value(v)=0$, then $f_v=0$
		\end{enumerate}
		\item If $v$ is a non-terminal vertex with $index(v)=i$, then $f_v$ is the function \\ 
		$f_v(v_i) = x_i(f_{child_1(v)}(v_{i-1}), ..., f_{child_l(v)}(v_{i-n}))$.
	\end{enumerate}
\end{definition}

The recursive nature of the Boolean Function definition in logic networks can be seen in \ref*{fig:LNEx}.

\begin{definition}[Majority Function]\label{Def:majf}
	The ternary Boolean majority function is defined as: $\langle a, b, c \rangle = ab + ac + bc$, so that the function value equals the majority of it's incoming values.\\
	It follows: $\langle a, b, 0 \rangle = a \cdot b$ and $\langle a, b, 1 \rangle = a + b$.
\end{definition}

Adapting the names used in the underlying literature, a terminal vertex is referred to as \textit{primary input} (PI) with their set denoted as $I$. The set of non-terminal vertices referred to as \textit{nodes} is denoted as $\Lambda$. The definition requires $I \cap \Lambda = \emptyset$. An edge connecting a child $\nu_i$ and a parent vertex $\nu_j$ is called a \textit{signal}. With $i < j$ the notation of a signal is given as $(\nu_i, \nu_j)$. The set of all signals is denoted as $\Sigma$. If an edge is dangling, so it doesn't point to another vertex, it is called \textit{primary output} (PO) and their set is denoted as $O$. Therefore also $\Sigma \cap O = \emptyset$ holds. From the definition of a logic network, we can now describe it as acyclic directed graph $N = (\Lambda, I, \Sigma, O)$.\\
As already mentioned in subsection \ref{subsec:boolfunc}, a universal set of two Boolean functions can form any Boolean algebra.
As long as this universality is contained the set of node functions in a logic network can be extended arbitrarily. Common logic networks containing only two network functions are e.g. \textit{AND-Inverter Graphs} (AIGs) allowing only conjunction and negation. Another binary logic network, whcih is used in the QCA domain, is the \textit{Majority-Inverter Graphs} (MIGs) utilizing the ternary majority function and negation. But there also exists a wide range of logic networks that permit more than just two-node functions. One example is the \textit{XOR-AND-Inverter Graph} (XAG) with the parity function, conjunction, and negation functions, respectively \cite{Walter}.\\
As part of the logic synthesis, a suitable logic network representation of the combinational circuit has to be determined. Because, even though these logic networks can implement any Boolean function given by a specification, not every logic network can be synthesized into any given technology.
Looking at the current standard technology \textit{complementary metal-oxidesemiconductor} (CMOS), the logic network is then synthesized by using building blocks consisting of \textit{metal-oxide-semiconductor field-effect transistors} (MOSFETs), the elemental unit in this technology.\\

One drawback, that sticks to this definition of logic networks and holds also true for the aforementioned representations is that they are all \textit{non-canonical}, which means that a given function can be represented by different logic networks. This property can be explained by the fact that nodes with the identity function are allowed, which can be inserted everywhere in the logic network, while the function representation of the logic network stays the same. Even the exclusion of such identity nodes has no impact, since simple node combinations, like two negotiation nodes, collapse to the identity function. Following this argumentation, there exists an infinite number of logic networks representing each one Boolean Function, resulting in the widely accepted assumption, that the determination of an optimal logic network is an $\mathcal{NP}$-complete problem \cite{Walter}. Attempts to create canonical logic networks, seem to evade this problem, but include co$\mathcal{NP}$-complete problems in itself \cite{LogicNetwork}. Algorithms used for logic synthesis are therefore based on approximate solutions.


\section{QCA Technology}

In order to fulfill the well-known Moore's law \cite{Moores_Law}, demanding a doubling of transistors on a chip every two years, CMOS technology is facing a multitude of challenges. Most notable are the short-channel effect, impurity variations, and most importantly, the heat dissipation resulting from static and dynamic power losses \cite{challenges_1, challenges_2, challenges_3}. To tackle these challenges among others the International Roadmap for Devices and Systems (IRDS, former ITRS), provides a platform proposing solutions within the semiconductor domain, e.g. new materials and multi-core architectures. But new technologies are also being researched, including quantum computing and the domain of \textit{Field-Coupled Nanocomputing} (FCN). This work focuses on one of the most promising FCN technologies, namely \textit{Quantum-dot Cellular Automata} (QCA). The main difference of this technology compared to CMOS is the representation of logical modes, using the location of electron pairs in QCA-cells, rather than voltage levels. Data between cells are transferred based on Coulomb repulsion, using electromagnetic fields, enabling the technology to achieve high performance in terms of device density, clock frequency, and power consumption \cite{mohammadi2016efficient}. Hence, QCA tackles exactly the main issues faced with CMOS technology and provides a promising digital system for the future \cite{ahmad2018optimal}. However, QCA also presents its own challenges in terms of the manufacturing process, manufacturing standards, and different design
methodologies \cite{Bennet_waveform}. Because this work focuses on the design of QCA circuits, it mainly views circuit parameters such as area, complexity, and clock delays \cite{ahmad2018optimal}. In order to allow an analysis under these parameters, first the QCA technology and the resulting design constraints have to be understood. Therefore, subesection \ref{subsec:cells} introduces QCA cells as building blocks for QCA gates, which are discussed in subesection \ref{subsec:gates}. After understanding the clocking in subsection \ref{subsec:clocking}, the constraints for the placement and routing problem can be formulated subsequently.

\subsection{Cells}\label{subsec:cells}

As already mentioned, in QCA technology logical states are no longer represented by voltage levels but by the location of electrons \cite{QCA_technology}. In order to achieve this property a nanosized structure is needed, which is capable of trapping electrons in a certain position. For this purpose so-called \textit{quantum-dots} (QDs) are utilized. A QD consists of several to one hundred
atoms of a semiconductor, and therefore quantum mechanics applies for their electrical properties. For this work it is sufficient to understand that every QD has a bound state, where a particle tends to be localized and the bound state is subject to a potential, which can be external or due to the presence of other particles. Because this enables QDs to have discrete electronic states, they are also referred to as \textit{artificial atoms}. A combination of them is used to build a QCA cell, also known as \textit{artificial molecule} \cite{Quantum_dots}. Figure \ref{fig:QCAStates} shows three such QCA cells, where the four circles at the corners of each QCA cell show the QDs or rather their quantum barriers, which are capable of trapping one electron. In addition, a cell contains two excess electrons, which can be localized by quantum dots. When a QD currently traps an electron, it is depicted black and an unoccupied QD is depicted white. Coulomb repulsion causes electrons to occupy diagonally opposed QDs, resulting in three possible cell states \cite{Sasamal2020QuantumDotCA, lent1997device, lent1994quantum}.\\
A stable state indicates that it is easily distinguishable from the usual energy band. Therefore, the energy difference between two consecutive energy states must be well above the thermal noise energy ($k_BT$). Only such states are suited for information transfer. The stable states can be derived from cell polarization, which can be $+1$ and $-1$ or $null$ in the unexcited state. The two stable states contain the same electrostatic energy and are used to encode the binary values $0$ and $1$ \cite{Sasamal2020QuantumDotCA}. Figure \ref{fig:QCAStates} shows three cells with possible states and their resulting polarizations and logical states.

As already stated, QDs can be influenced externally, allowing the designer to fix the polarization of a QCA cell. This effect is used to input information into one QCA cell, called the driver cell. When a driver cell is placed side-by-side with other QCA cells, its polarization causes the polarization of the adjacent cell to change. When the adjacent cell is polarized, it passes its state again to the next cell and so on \cite{lent1997device}. Figure \ref{fig:QCAWire} depicts such a structure, where the left-most cell represents the driver cell with fixed polarization representing a logic "1". With every cell passing its polarization to the cell to its right, the polarization of the right-most cell can be measured and the logic value, which propagated through the structure can be extracted. Due to the property of just passing the information from its input to its output, the shown structure represents a QCA wire.

\begin{figure}
	\centering
	\begin{tikzpicture}
		%One QCA-Cell
		\node (A1) at (0.6,1.5) {$0$};
		\draw[rounded corners] (0, 0) rectangle (1.2, 1.2) [label=north:$v_7$]{};
		\node (A2) at (0.6,-0.3) {$P = -1$};
		
		\draw (0.3,0.3) circle (2mm);
		\draw [fill = black] (0.9,0.3) circle (2mm);
		\draw [fill = black](0.3,0.9) circle (2mm);
		\draw (0.9,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{2}
		\node (B1) at (0.6+\x,1.5) {$1$};
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\node (B2) at (0.6+\x,-0.3) {$P = +1$};
	
		\draw [fill = black] (0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black] (0.9+\x,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{4}
		\node (C1) at (0.6+\x,1.5) {$null$};
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\node (C2) at (0.6+\x,-0.3) {$P = 0$};
		
		\draw (0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw (0.9+\x,0.9) circle (2mm);
		
		
	\end{tikzpicture} 

	\caption{QCA-Cell sates} \label{fig:QCAStates}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}
		%One QCA-Cell
		\node (A1) at (-0.3,0.6) {$1$};
		\draw[rounded corners] (0, 0) rectangle (1.2, 1.2) [label=north:$v_7$]{};
		
		\draw [fill = black](0.3,0.3) circle (2mm);
		\draw (0.9,0.3) circle (2mm);
		\draw (0.3,0.9) circle (2mm);
		\draw [fill = black](0.9,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{1.2}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		
		\draw [fill = black] (0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black] (0.9+\x,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{2.4}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\draw [fill = black](0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black](0.9+\x,0.9) circle (2mm);
		
		%One QCA-Cell
		\def\x{3.6}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\draw [fill = black](0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black](0.9+\x,0.9) circle (2mm);
		
		%One QCA-Cell
		\def\x{4.8}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\draw [fill = black](0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black](0.9+\x,0.9) circle (2mm);
		\node (C1) at (1.5+\x,0.6) {$1$};
		
		
	\end{tikzpicture} 
	
	\caption{Adjacent QCA-cells forming a wire segment} \label{fig:QCAWire}
\end{figure}

\subsection{Gates}\label{subsec:gates}

In this subsection, QCA cells are combined to form different logic gates, which form the gate library used later for the design of QCA logical circuits. Some of these gates are inherited from the QCA ONE library \cite{QCA_scl}, which is already used fully \cite{peng2020spars} or partially \cite{ortho, greedy_tile} as a basis for some works.
The QCA ONE library proposes gates formed by one tile as well as gates formed by multiple tiles. A major drawback of this library is the prerequisite of a clocking scheme (USE) in order to form multiple tile gates. This restricts the underlying placement and routing algorithm in the clocking domain. Also manual changes of the standard cells clock zones, size or positioning is not allowed \cite{QCA_scl}, imposing the designer with even more restrictions. For this work, the standard cell library should contain only gates that occupy one tile. Every other logic function is composed out of these standard cells. The tiles used are of the dimension $5 \times 5$ cells, which means that all standard gates are reduced to this area.\\
%%%%%%Inverter
\begin{figure}
	\centering
	\subfigure[$45^{\circ}$ Inverter]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (A1) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{2.16}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.3, 0.36+\o) {$\neg i$};
			
		\end{tikzpicture} 
		\label{subfig:45Inverter}
	}
	\subfigure[Standard Inverter]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (A1) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\x{2.16}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.3, 0.36) {$\neg i$};
		\end{tikzpicture} 
		\label{subfig:StandardInverter}
	}
	\caption{Different QCA Inverter representations} \label{fig:QCAInverter}
\end{figure}

Until now, inverters and majority gates have been the main building blocks of QCA circuits. Starting with the inverter or NOT gate, the simplest implementation is shown in figure \ref{subfig:45Inverter}. It consists of two wire segments which are shifted by exactly one cell height, so that the polarization is transferred diagonally resulting in an inversion of the input \cite{Sasamal2020QuantumDotCA}. In order to get a more robust gate regarding disturbance, the C-shaped inverter shown in figure \ref{subfig:StandardInverter} is introduced \cite{QCA_scl}. This gate is used as standard in many libraries and works \cite{peng2020spars, greedy_tile, sequential_cell_one, USE}, but it should be mentioned that this implementation is really prone to complex single-electron faults \cite{SingelElectronFaults} and even common displacement faults \cite{Inverter_displacements}, suggesting the addition of an inverter leg that results in an E-shaped gate structure. Nevertheless the C-shaped inverter gate is part of the QCA ONE library and is also selected as standard gate for this work.\\
%%%%%Majority gates
\begin{figure}
	\centering
	\subfigure[Rotated Majority gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_2$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw [fill = black](0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{1.44}
			\def\x{0}
			\node (I1) at (-0.3,0.36+\o) {$i_1$};
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			\node (I3) at (0.72 + \x + 0.3, 0.36+\o) {$i_3$};
			
			%One QCA-Cell
			\def\o{1.44}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36+\o) {$\langle i_1, i_2, i_3\rangle$};
			
		\end{tikzpicture} 
		\label{subfig:rotatedMaj}
	}
	\subfigure[Standard Majority Gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_2$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,1.7) {$i_1$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,-1.02) {$i_3$};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36) {$\langle i_1, i_2, i_3\rangle$};
		\end{tikzpicture} 
		\label{subfig:StandardMaj}
	}\\
	\subfigure[Standard AND Gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_1$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners, fill=black] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw [fill = white](0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw [fill = white](0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,1.7) {$0$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,-1.02) {$i_2$};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36) {$\langle 0, i_1, i_2\rangle$};
		\end{tikzpicture} 
		\label{subfig:StandardAnd}
	}
	\subfigure[Standard OR Gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_1$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners, fill=black] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = white](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = white](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,1.7) {$1$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,-1.02) {$i_2$};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36) {$\langle 0, i_1, i_2\rangle$};
		\end{tikzpicture} 
		\label{subfig:StandardOr}
	}
	\caption{The QCA Majority gate} \label{fig:QCAMaj}
\end{figure}

Due to its importance in QCA technology, the next gate, which needs to be investigated, is the most important gate. Definition \ref{Def:majf} suggests that the implementation of this function in CMOS technology requires multiple AND and OR gates to be placed and routed. In QCA technology on the other hand a majority function can be represented by exactly one gate, making it one of the major advantages over CMOS technology. There are two main implementations of the majority gate. The rotated majority gate in Figure \ref{subfig:rotatedMaj}, which is used in QCA ONE, and the $+$-majority gate shown in Figure \ref{subfig:StandardMaj}. Both of these implementations have their advantages and drawbacks. On the one hand, the rotated majority gate exhibits a sufficiently high degree of fault tolerance against cell displacement or misalignment but has a very poor degree of fault tolerance against single cell omission or extra cell deposition \cite{majorityrotated}. On the other hand, the $+$-majority gate is very prone to cell displacement, but it is also used as a building block for the AND and OR gates in most work. This means that the fabrication process for all these gates is very similar and since this work is aimed to enhance the design process of QCA circuits, the $+$-majority gate is chosen as standard gate for this work.\\
Following Definition \ref{Def:majf} the AND gate can be derived by fixing one input of the majority gate to logic $0$, while the OR gate is obtained by fixing one input to logic $1$. The resulting gates, which are also part of the standard gate library of this work are shown in figure \ref{subfig:StandardAnd}.\\

\begin{figure}
	\centering
	\subfigure[Straight wire]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
%			\def\o{0.72}
%			\def\x{0.72}
%			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
%			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%			\node (I2) at (0.36 + \x,1.7) {$i_1$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners, draw=white] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
%			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node(I2) at (0.36 + \x,-1.02) {};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.7, 0.36) {$o = i$};
		\end{tikzpicture} 
		\label{subfig:straight_wire}
	}
\subfigure[Bent wire]
{
	\centering
	\begin{tikzpicture}
		%One QCA-Cell
		\node (I2) at (-0.3,0.36) {$i$};
		\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
		
		\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
		\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
		\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
		\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
		
		
		%One QCA-Cell
		\def\x{0.72}
		\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
		
		\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
		\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
		\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
		\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
		
		%One QCA-Cell
%		\def\o{0.72}
%		\def\x{0.72}
%		\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
%		\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%		\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%		\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%		\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%		\node (I2) at (0.36 + \x,1.7) {$i_1$};
		
		
		%One QCA-Cell
		\def\o{-0.72}
		\def\x{0.72}
		\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
		\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
		\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
		\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
		\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
		\node (I2) at (0.36 + \x,-1.02) {$o=i$};
		
		
		\node (C1) at (0.72 + \x + 0.7, 0.36) {};
	\end{tikzpicture} 
	\label{subfig:bent_wire}
}
\subfigure[Fan-out wire]
{
	\centering
	\begin{tikzpicture}
		%One QCA-Cell
		\node (I2) at (-0.3,0.36) {$i$};
		\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
		
		\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
		\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
		\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
		\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
		
		
		%One QCA-Cell
		\def\x{0.72}
		\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
		
		\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
		\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
		\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
		\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
		
		%One QCA-Cell
%		\def\o{0.72}
%		\def\x{0.72}
%		\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
%		\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%		\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
%		\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%		\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
%		\node (I2) at (0.36 + \x,1.7) {$i_1$};
		
		
		%One QCA-Cell
		\def\o{-0.72}
		\def\x{0.72}
		\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
		\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
		\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
		\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
		\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
		\node (I2) at (0.36 + \x,-1.02) {$o_2 = i$};
		
		%One QCA-Cell
		\def\x{1.44}
		\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
		
		\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
		\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
		\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
		\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
		
		\node (C1) at (0.72 + \x + 0.7, 0.36) {$o_1 = i$};
	\end{tikzpicture} 
	\label{subfig:fanout_wire}
}

	\caption{QCA wires}\label{fig:QCA_wires}
\end{figure}

Different than in CMOS technology in QCA, wires must also be introduced as gates. As already seen in figure \ref{fig:QCAWire} a QCA wire also consists of QCA cells and therefore forms a gate. Since wires do not add functionality to the logic, they are viewed as logic gates representing the unity function. This property has the huge drawback that the cost of wires is comparable with other logic gates, which is being used as one major cost metric for the circuit design. Until now only straight planar wires have been introduced. From the implementation of the majority gate it can already seen that data is not only transferred in the x-Dimension but also in y-Dimension, requiring the wiring to also be able to flow in both dimensions. When gates are placed side by side in two dimensions, the resulting circuit can be viewed as a 2D-grid. In order to allow information to change its propagation direction from the x-direction to the y-direction and vice versa, also bent wires have to be introduced. They are depicted in Figure \ref{subfig:bent_wire} and show a 90-degree bend. Given that all tiles can be rotated by $90^{\circ}$, $180^{\circ}$ and $270^{\circ}$ respectively, a tile connected to a bent wire can be routed to each adjacent tile of a bent wire. Also, since all gates introduced so far have a fan-out of one, we need a fan-out node to duplicate signals. This is done by adding a bent wire to a straight wire resulting in the fan-out shown in Figure \ref{subfig:fanout_wire}.\\
%%%%Wire crossing
\begin{figure}
	\centering
	\subfigure[Coplanar wire crossing]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			%\node (I2) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.5, 1.2*0.5) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.5,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black](0.9*0.5,0.9*0.5) circle (2*0.5mm);
			
			
			%One QCA-Cell
			\def\x{0.6}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.5 + \x, 1.2*0.5) {};
			
			\draw [fill = black] (0.3*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5+\x,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black] (0.9*0.5+\x,0.9*0.5) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{0}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw [fill = black](0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw (0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\x{1.8}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.5 + \x, 1.2*0.5) {};
			
			\draw [fill = black] (0.3*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5+\x,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black] (0.9*0.5+\x,0.9*0.5) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\x{2.4}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.5 + \x, 1.2*0.5) {};
			
			\draw [fill = black] (0.3*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5+\x,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black] (0.9*0.5+\x,0.9*0.5) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{0.6}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw (0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw [fill = black](0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{1.2}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw [fill = black](0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw (0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{-0.6}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw (0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw [fill = black](0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{-1.2}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw [fill = black](0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw (0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
		\end{tikzpicture} 
		\label{subfig:CoplanarWire}
	}
	\subfigure[Multi-layer wire crossing \cite{Inverter_displacements}]
	{
		\centering
		\includegraphics[scale=0.25]{wire_crossing}
		\label{subfig:mlwirecrossing}
	}
	
	\caption{Different QCA wire crossing implementations} 
\end{figure}
The last special case of wires is the crossing case. By rotating the cells of one wire string by $45^{\circ}°$ the rotated cells do not have crosstalk with nonrotated cells \cite{Inverter_displacements} as shown in figure \ref{subfig:CoplanarWire}. This solution is very handy because it supports the planar structure of the circuit and is therefore called \textit{coplanar wire crossing}. Further the possibility of multi-layer QCA has been investigated \cite{multi_lyer_wire_crossing} and found especially useful in the case of wire crossings. To use this, one wire string is raised to an additional higher layer, which is connected with a vertical interconnect as in figure \ref{subfig:mlwirecrossing}. The signal transmission in the vertical-stacked cells works just as in the horizontal direction. To impede any crosstalk between the wire strings, two intermediate layers of cells are used in the vertical direction. Theoretically, the top layer cannot only be used as wire, but since the signal distribution works just as in the ground layer gates can also be placed in these multi-layers. Simulations have shown that coplanar crossovers significantly reduce the coupling between the horizontal wire segments. This makes the horizontal interconnect very sensitive to crosstalk and therefore highly prone to cell displacements. Multilayer circuits, on the other hand, show high robustness and therefore are used as standard in this library. In the gate $5 \times 5$ representation of the multilayer interconnect, the top wire string is described with a $\times$, while the vertical layers are described with a circle. In Figure \ref{fig:StandardCellLibrary} all gates used in this work are summarized.

\begin{figure}
	\centering
	\subfigure[INV]
	{
		\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
			\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
			
			\foreach \x/\y in {0.9/0.9, 0.9/0.45, 1.35/0.45, 0.45/0.45, 1.35/0, 0.45/0, 0.9/-0.45, 0.9/-0.9}
			{
				\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
				\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
				\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
				\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
				\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
			}
		\end{tikzpicture}
	}
\subfigure[MAJ]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0, 1.35/0, 1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}
\subfigure[AND]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0, 1.35/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
		\foreach \x/\y in {1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=black] (\x, 0 + \y) rectangle 	(1.2/3 + \x, 1.2/3 + \y){};
			\draw [fill=white](0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw [fill=white](0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}
\subfigure[OR]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0, 1.35/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
		\foreach \x/\y in {1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=black] (\x, 0 + \y) rectangle 	(1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw [fill=white](0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw [fill=white](0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}\\
\subfigure[Wire]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}
\subfigure[Bent wire]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0/0, 0.45/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
	\label{subfig:BentWire}
}
\subfigure[Fanout]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
	\label{subfig:FanoutWire}
}
\subfigure[Wire crossing]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0/0, 0.45/0, 1.35/0, 1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
		\foreach \x/\y in {0.9/-0.45, 0.9/0, 0.9/0.45}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle 	(1.2/3 + \x, 1.2/3 + \y){};
			\node (X) at (\x + 0.5*0.45- 0.025, \y + 0.5*0.45 - 0.025) {$\times$};
			
		}
		\foreach \x/\y in {0.9/-0.9, 0.9/0.9}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (\x + 0.5*0.45- 0.025, \y + 0.5*0.45 - 0.025) circle (1.4mm){};
			
		}
	\end{tikzpicture}
}
	\caption{QCA Standard Library}\label{fig:StandardCellLibrary}
\end{figure}

\subsection{Clocking}\label{subsec:clocking}

As mentioned above, data transfer in the QCA paradigm is accomplished by cell-to-cell interaction. Given a fixed polarization of a cell, the next cell reacts to the Coulomb repulsion and changes its polarization accordingly. Looking at the wire segment in figure \ref{fig:QCAWire}, the leftmost cell has a fixed polarization and is called the input. After some time the information propagates through to the rightmost cell, representing the output of the simplified QCA-circuit. Generally, a QCA circuit can be seen as an assembly of cells on a two-dimensional grid or array, where each cell has a position with $x$ and $y$ coordinates assigned. Every driver cell with fixed polarization is called an input cell and drives the other cells gradually into matching polarization. When all cells have matching polarization, meaning that the electrons in two adjacent cells have the maximum distance and therefore minimum energy following Coulomb repulsion, the QCA array is said to be in \textit{ground state}. When a cell has no adjacent cell in the distribution direction, it is called an output cell. While the polarization is propagating through the array, the direction of the propagation is always pointing away from the input cells and to the output cells. In reality the propagation doesn't go gradually through the array but rather sloshes around, showing a quite unpredictable behavior. This is the first reason, why a \textit{clocking}, involving well-defined states for the polarization of the cells and enabling a well-ordered signal propagation, is introduced. Another reason for a clocking is, that for the described straight forward process called abrupt switching with dissipative coupling to the environment, the QCA-array has to be embedded into a CMOS environment, as shown in figure \ref{fig:QCA_array}. In the following, a short evolution of this primitive clocking to the currently used clocking is described.

\begin{figure}
	\centering
	\includegraphics[scale=0.6]{QCA_array}
	\caption{Schematic of a combined QCA and CMOS system \cite{lent1994quantum}.} 
	\label{fig:QCA_array}
\end{figure}

Therefore, the QCA-Array is divided into smaller decoupled sub-regions called \textit{clock zones} and each clocking zone receives an external signal, a clock, assigned. The clock can then activate and deactivate the cells of a zone in a way that the information propagates gradually from one zone to the next through the whole QCA circuit. In the approach first used the clock decreases the QD barriers of all cells in a clocking zone, when applying a new input. This means that the electrons are not trapped and can move freely following Coulomb repulsion, therefore taking over the polarization of the input cell. When all cells in the region are stable, the barriers are raised again, localizing the electrons in the cells, which now have the desired polarization. Meanwhile the barriers of the subsequent clocking zone are lowered simultaneously, the previous sub-region acts as fixed input and again the polarization is taken over. In this way, the information gradually propagates through the whole circuit \cite{lent1997device}. Today's used approaches create electrical fields with an external clock generator and distribute it to the cells through the device substrate using embedded electrodes. Thereby the energy level of the \textit{null} state can be controlled, resulting in a equivalent effect as in the former approach \cite{Walter}.\\
\begin{figure}
	\centering
	\includegraphics[scale=0.41]{clocked_wire}
	\caption{QCA wire devised into the four clock zones according to Bennet clocking}\label{fig:QCA_wire_clocked}
\end{figure}
A wire, divided in such clock zones is shown in \ref{fig:QCA_wire_clocked}. The colors of the zones and cells, as well as the zone number, show redundant information about the type of clocking zone. They differ in the external applied electrical field and therefore the energy of the cells. In QCA the clocking is divided into the four consecutive states, \textit{switch}, \textit{hold}, \textit{release} and \textit{relax}. They are aligned in a pipeline-like structure, where each of these states is phase-shifted by $\pi/2$, forming a $2\pi$ clock cycle. In the switch phase, cells start to get polarized, dependent on the polarization of the driving cell. When the cells are polarized they get fixed in the hold-phase. Afterwards in the release-phase the excitation gradually decreases, resulting in the unexcited relax-state \cite{Sasamal2020QuantumDotCA}. After one clocking cycle, the next clocking cycle starts with the same order of states also notated with numbers $i = \{1, 2, 3, 4\}$. Hence, for consecutive clocking numbers holds $(i_{next} = i_{previous}+1 \mod clk)$. The scheme of such a pipeline as clocking is depicted exemplaryly in Figure \ref{subfig:Landauer}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
	\centering
	\subfigure[Landauer clocking]{\includegraphics[scale=0.41]{Landauer_clocking}\label{subfig:Landauer}}
	\subfigure[Bennet clocking]{\includegraphics[scale=0.41]{Bennet_clocking}\label{subfig:Bennet}}
	\caption{QCA clocking pipeline} \label{fig:QCAClockpipeline}
\end{figure}


The described clocking is named \textit{Landauer clocking}. The inventor Rolf Landauer himself pointed out the vast power dissipation of this clocking mechanism. The main cause for the high power dissipation is the \textit{erase} function, which happens because in the Landauer clocking the release state directly follows on the hold phase, irreversibly erasing the information and therefore transforming it into heat \cite{landauer1961irreversibility}. To tackle this problem in the QCA domain, Landauer pointed out, that the erase function has to be eliminated from the clocking. He argues that every erased bit dissipates at least $k_BT\ln(2)$ in heat dissipation \cite{keyes1970minimal}. Exemplary if a QCA-cell has size $1nm \times 1nm$ and operating frequency of $100 GHz$, the corresponding density of devices results to $10^{14}$ $cm^{-2}$. Further a dissipation of $0.1 eV$ every clock cycle is assumed, resulting in a total power dissipation of 160 $kW$ $cm^{-2}$. This directly yields the statement that a device operating with this clocking would be inoperable (it would evaporate due to heat) \cite{lent2006bennett}. The \textit{Bennet clocking} tackles exactly this problem by altering the timing of the clocking signals. Just as in the Landauer clocking, the clocking wave propagates in one direction, but leaving no trailing edge, when information is passed. Instead, the cells will be held in the excited state until the information propagates through the whole QCA-array. When the output was read, the excitation is released in reverse order resulting in no erase functions. This means, that this \textit{quasi-adiabatic} clocking leads to a minimal power dissipation but with two constraints. The effective clock rate is at least halved due to the additional backwards propagation and since only one signal vector can be transmitted through the system, the pipeline capabilities are reduced \cite{lent2006bennett}. The resulting clocking scheme for Bennet clocking is shown in figure \ref{subfig:Bennet}.\\
\begin{figure}
	\centering
	\includegraphics[scale=0.9]{cell_based_mux}
	\caption{Cell based layout of a 2:1 mux \cite{majeed2019optimal}}\label{fig:cell_based_mux}
\end{figure}
In order to apply Bennet clocking, it was already stated that the QCA-array has to be divided into clock zones. Allowing an arbitrary number of cells in one clock zone gives lots of freedom in designing clock zones with variable geometries. This clocking is referred to as \textit{cell-based} and increases the fabrication process due to its variety in clock zone geometries. Assuming the necessity of an uniform fabrication in order to fabricate circuits with millions of cells, this clocking gets infeasible for large circuits. Since in this scheme single cells can be clocked, also electrodes of the same size must be fabricated, in order to provide a clocking signal to the single-cell region. Since this is also not feasible, this design is obsolete. An example of a cell-based clocking design of a 2:1 mux can be seen in \ref{fig:cell_based_mux}. To achieve uniform clock zones with a possible distribution of clocking signals, the \textit{tile-based} clocking is introduced. The approach of this design is to provide uniform tiles of size $3 \times 3$ or $5 \times 5$. For clocking tiles larger than this, information propagation was suggested to be erroneous, also following an argument against cell-based clocking \cite{taucer2015consequences}.


\begin{figure}
	\newcommand*{\xMin}{0}%
	\newcommand*{\xMax}{4}%
	\newcommand*{\xMaxc}{3}%
	\newcommand*{\yMin}{0}%
	\newcommand*{\yMax}{4}%
	\newcommand*{\yMaxc}{3}%
	\subfigure[2DDWave]
	{
		\begin{tikzpicture}
			
			\foreach \i in {\xMin,...,\xMax} {
				\draw [very thin,gray] (\i,\yMin) -- (\i,\yMax)  node [below] at (\i,\yMin) {};
			}
			\foreach \i in {\yMin,...,\yMax} {
				\draw [very thin,gray] (\xMin,\i) -- (\xMax,\i) node [left] at (\xMin,\i) {};
			}
			
			
			\draw[fill=darkgray]  (0, 1) -- (1, 1) -- (1,0) -- (0,0) -- cycle;
			\draw[fill=white]  (1, 1) -- (2, 1) -- (2,0) -- (1,0) -- cycle;
			\draw[fill=lightgray]  (2, 1) -- (3, 1) -- (3,0) -- (2,0) -- cycle;
			\draw[fill=gray]  (3, 1) -- (4, 1) -- (4,0) -- (3,0) -- cycle;
			
			\draw[fill=gray]  (0, 2) -- (1, 2) -- (1,1) -- (0,1) -- cycle;
			\draw[fill=darkgray]  (1, 2) -- (2, 2) -- (2,1) -- (1,1) -- cycle;
			\draw[fill=white]  (2, 2) -- (3, 2) -- (3,1) -- (2,1) -- cycle;
			\draw[fill=lightgray]  (3, 2) -- (4, 2) -- (4,1) -- (3,1) -- cycle;
			
			\draw[fill=lightgray]  (0, 3) -- (1, 3) -- (1,2) -- (0,2) -- cycle;
			\draw[fill=gray]  (1, 3) -- (2, 3) -- (2,2) -- (1,2) -- cycle;
			\draw[fill=darkgray]  (2, 3) -- (3, 3) -- (3,2) -- (2,2) -- cycle;
			\draw[fill=white]  (3, 3) -- (4, 3) -- (4,2) -- (3,2) -- cycle;
			
			\draw[fill=white]  (0, 4) -- (1, 4) -- (1,3) -- (0,3) -- cycle;
			\draw[fill=lightgray]  (1, 4) -- (2, 4) -- (2,3) -- (1,3) -- cycle;
			\draw[fill=gray]  (2, 4) -- (3, 4) -- (3,3) -- (2,3) -- cycle;
			\draw[fill=darkgray]  (3, 4) -- (4, 4) -- (4,3) -- (3,3) -- cycle;
			
			\node[text=white] (A1) at (0.85,0.18) {$4$};
			\node[text=black] (A1) at (1.85,0.18) {$1$};
			\node[text=black] (A1) at (2.85,0.18) {$2$};
			\node[text=white] (A1) at (3.85,0.18) {$3$};
			
			\node[text=white] (A1) at (0.85,1.18) {$3$};
			\node[text=white] (A1) at (1.85,1.18) {$4$};
			\node[text=black] (A1) at (2.85,1.18) {$1$};
			\node[text=black] (A1) at (3.85,1.18) {$2$};
			
			\node[text=black] (A1) at (0.85,2.18) {$2$};
			\node[text=white] (A1) at (1.85,2.18) {$3$};
			\node[text=white] (A1) at (2.85,2.18) {$4$};
			\node[text=black] (A1) at (3.85,2.18) {$1$};
			
			\node[text=black] (A1) at (0.85,3.18) {$1$};
			\node[text=black] (A1) at (1.85,3.18) {$2$};
			\node[text=white] (A1) at (2.85,3.18) {$3$};
			\node[text=white] (A1) at (3.85,3.18) {$4$};
			
			
		\end{tikzpicture}
		\label{subfig:2DD}
	}
	\subfigure[USE]
	{
		\begin{tikzpicture}
			\foreach \i in {\xMin,...,\xMax} {
				\draw [very thin,gray] (\i,\yMin) -- (\i,\yMax)  node [below] at (\i,\yMin) {};
			}
			\foreach \i in {\yMin,...,\yMax} {
				\draw [very thin,gray] (\xMin,\i) -- (\xMax,\i)
				node [left] at (\xMin,\i) {};
			}
			\draw[fill=lightgray]  (0, 1) -- (1, 1) -- (1,0) -- (0,0) -- cycle;
			\draw[fill=white]  (1, 1) -- (2, 1) -- (2,0) -- (1,0) -- cycle;
			\draw[fill=darkgray]  (2, 1) -- (3, 1) -- (3,0) -- (2,0) -- cycle;
			\draw[fill=gray]  (3, 1) -- (4, 1) -- (4,0) -- (3,0) -- cycle;
			
			\draw[fill=gray]  (0, 2) -- (1, 2) -- (1,1) -- (0,1) -- cycle;
			\draw[fill=darkgray]  (1, 2) -- (2, 2) -- (2,1) -- (1,1) -- cycle;
			\draw[fill=white]  (2, 2) -- (3, 2) -- (3,1) -- (2,1) -- cycle;
			\draw[fill=lightgray]  (3, 2) -- (4, 2) -- (4,1) -- (3,1) -- cycle;
			
			\draw[fill=darkgray]  (0, 3) -- (1, 3) -- (1,2) -- (0,2) -- cycle;
			\draw[fill=gray]  (1, 3) -- (2, 3) -- (2,2) -- (1,2) -- cycle;
			\draw[fill=lightgray]  (2, 3) -- (3, 3) -- (3,2) -- (2,2) -- cycle;
			\draw[fill=white]  (3, 3) -- (4, 3) -- (4,2) -- (3,2) -- cycle;
			
			\draw[fill=white]  (0, 4) -- (1, 4) -- (1,3) -- (0,3) -- cycle;
			\draw[fill=lightgray]  (1, 4) -- (2, 4) -- (2,3) -- (1,3) -- cycle;
			\draw[fill=gray]  (2, 4) -- (3, 4) -- (3,3) -- (2,3) -- cycle;
			\draw[fill=darkgray]  (3, 4) -- (4, 4) -- (4,3) -- (3,3) -- cycle;
			
			\node[text=black] (A1) at (0.85,0.18) {$2$};
			\node[text=black] (A1) at (1.85,0.18) {$1$};
			\node[text=white] (A1) at (2.85,0.18) {$4$};
			\node[text=white] (A1) at (3.85,0.18) {$3$};
			
			\node[text=white] (A1) at (0.85,1.18) {$3$};
			\node[text=white] (A1) at (1.85,1.18) {$4$};
			\node[text=black] (A1) at (2.85,1.18) {$1$};
			\node[text=black] (A1) at (3.85,1.18) {$2$};
			
			\node[text=white] (A1) at (0.85,2.18) {$4$};
			\node[text=white] (A1) at (1.85,2.18) {$3$};
			\node[text=black] (A1) at (2.85,2.18) {$2$};
			\node[text=black] (A1) at (3.85,2.18) {$1$};
			
			\node[text=black] (A1) at (0.85,3.18) {$1$};
			\node[text=black] (A1) at (1.85,3.18) {$2$};
			\node[text=white] (A1) at (2.85,3.18) {$3$};
			\node[text=white] (A1) at (3.85,3.18) {$4$};
		\end{tikzpicture}
		\label{subfig:USE}
	}
	\subfigure[RES]
	{
		\begin{tikzpicture}
			\foreach \i in {\xMin,...,\xMax} {
				\draw [very thin,gray] (\i,\yMin) -- (\i,\yMax)
				node [below] at (\i,\yMin) {};
			}
			\foreach \i in {\yMin,...,\yMax} {
				\draw [very thin,gray] (\xMin,\i) -- (\xMax,\i)
				node [left] at (\xMin,\i) {};
			}
			\draw[fill=white]  (0, 1) -- (1, 1) -- (1,0) -- (0,0) -- cycle;
			\draw[fill=darkgray]  (1, 1) -- (2, 1) -- (2,0) -- (1,0) -- cycle;
			\draw[fill=gray]  (2, 1) -- (3, 1) -- (3,0) -- (2,0) -- cycle;
			\draw[fill=lightgray]  (3, 1) -- (4, 1) -- (4,0) -- (3,0) -- cycle;
			
			\draw[fill=lightgray]  (0, 2) -- (1, 2) -- (1,1) -- (0,1) -- cycle;
			\draw[fill=gray]  (1, 2) -- (2, 2) -- (2,1) -- (1,1) -- cycle;
			\draw[fill=darkgray]  (2, 2) -- (3, 2) -- (3,1) -- (2,1) -- cycle;
			\draw[fill=white]  (3, 2) -- (4, 2) -- (4,1) -- (3,1) -- cycle;
			
			\draw[fill=white]  (0, 3) -- (1, 3) -- (1,2) -- (0,2) -- cycle;
			\draw[fill=lightgray]  (1, 3) -- (2, 3) -- (2,2) -- (1,2) -- cycle;
			\draw[fill=white]  (2, 3) -- (3, 3) -- (3,2) -- (2,2) -- cycle;
			\draw[fill=darkgray]  (3, 3) -- (4, 3) -- (4,2) -- (3,2) -- cycle;
			
			\draw[fill=darkgray]  (0, 4) -- (1, 4) -- (1,3) -- (0,3) -- cycle;
			\draw[fill=white]  (1, 4) -- (2, 4) -- (2,3) -- (1,3) -- cycle;
			\draw[fill=lightgray]  (2, 4) -- (3, 4) -- (3,3) -- (2,3) -- cycle;
			\draw[fill=gray]  (3, 4) -- (4, 4) -- (4,3) -- (3,3) -- cycle;
			
			\node[text=black] (A1) at (0.85,0.18) {$1$};
			\node[text=white] (A1) at (1.85,0.18) {$4$};
			\node[text=white] (A1) at (2.85,0.18) {$3$};
			\node[text=black] (A1) at (3.85,0.18) {$2$};
			
			\node[text=black] (A1) at (0.85,1.18) {$2$};
			\node[text=white] (A1) at (1.85,1.18) {$3$};
			\node[text=white] (A1) at (2.85,1.18) {$4$};
			\node[text=black] (A1) at (3.85,1.18) {$1$};
			
			\node[text=black] (A1) at (0.85,2.18) {$1$};
			\node[text=black] (A1) at (1.85,2.18) {$2$};
			\node[text=black] (A1) at (2.85,2.18) {$1$};
			\node[text=white] (A1) at (3.85,2.18) {$4$};
			
			\node[text=white] (A1) at (0.85,3.18) {$4$};
			\node[text=black] (A1) at (1.85,3.18) {$1$};
			\node[text=black] (A1) at (2.85,3.18) {$2$};
			\node[text=white] (A1) at (3.85,3.18) {$3$};
		\end{tikzpicture}
		\label{subfig:RES}
	}
	
	\caption{Different clocking Schemes in QCA} \label{fig:ClockingSchemes}
\end{figure}

The tile-based clocking leads to several proposals of clocking-schemes, which give a certain distribution of clock zones. Since they follow an uniform pattern they can be extended easily for every size of the circuit. In figure \ref{fig:ClockingSchemes} three clocking schemes are shown, each of them based on a different idea. Since information flow is only allowed in ascending clock order modulo $clk$, the 2DDWave clocking scheme in figure \ref{subfig:2DD} only allows information to propagate in two directions, south and east \cite{2DD}. This simplicity allows no back propagation, prohibiting the placement and routing of sequential circuits. Also, it restricts gates in the scheme to have a maximum input size of two. The USE scheme,shown in figure \ref{subfig:USE}, tackles the first problem by introducing clocking loops into the scheme, giving the possibility to place sequential circuits \cite{USE}. To tackle the second problem, the RES scheme, shown in figure \ref{subfig:RES}, gives the opportunity to place gates of input size three. Since one tile is restricted to four adjacent tiles, of which one has to output the information of the gate on the tile, this gives the maximum input size allowed. This is especially important for the placement of majority gates \cite{RES}. In QCA technology, they can be represented by only one tile, making them a huge advantage over CMOS technology. This is further evaluated in the next subsection on gates.

\section{P\&R problem} \label{sec:PR}

As seen in the last sections of this chapter, placement and routing are strongly related to the clocking inside the QCA domain. In this section, the denotation and constraints of placement and routing in the QCA domain are introduced. The P\&R problem evolves from a grid enabling tile-based design in conjunction with a logic network.

\begin{definition}
	A \textit{layout} is defined by a $w \times h$ grid $\Gamma_{w, h}$ and a graph $G(V, E)$, which is placed on the grid. Each \textit{tile} of the layout can be accessed via its $x$ and $y$ coordinates. The set of tiles is denoted as $T$ with $t = (x, y) \in T$. For any vertex of the graph, $v(x, y)$ is restricted to the boundaries $x < w$ and $y < h$. For edges $\{(x, y), (x^*, y^*)\}$ it holds $\vert x-x^*\vert+\vert y-y^*\vert = 1, 0 \leq x, x^* \leq w, 0 \leq y, y^* \leq h$.
\end{definition}

\begin{definition}
	A \textit{gate-level} layout describes a layout grid in combination with a logic network $N = (\Lambda, I, \Sigma, O)$. In addition to the already known mapping \textit{placement} $p$, which assigns nodes to tiles, there are two additional mappings. The \textit{routing} $r$, which assigns logic network signals to layout paths (connected tiles) and a \textit{clocking} $c$ assigning clock numbers to tiles. The gate-level layout is therefore described as $L = (\Gamma, N, p, r, c)$.\\
	Further, nodes placed on the gate-layout are referred to as \textit{gates}. Two tiles $t_i = (x_i, y_i)$ and $t_j = (x_j, y_j)$ where $\vert x_i-x_j\vert+\vert y_i-y_j\vert = 1$ are called \textit{adjacent}. A path which is wired through adjacent tiles is called \textit{wire}. In this context, one tile corresponds to a \textit{wire segment}. If neither a gate nor a wire segment is placed on a tile, it is empty. It follows that a layout with only empty tiles is also empty. A layout is said to be S-clocked if it follows a clocking scheme S. Otherwise, it is irregularly clocked. Moreover an adjacent tile of a tile $t \in T$, where $T$ is the set of all tiles, is incoming $t^-$ if $c(t) - c(t^-) \mod{clk} = 1$. This means that the incoming tile can forward information to the viewed tile according to pipelined clocking. For outgoing tiles $t^+$ it holds $c(t^+) - c(t) \mod{clk} = 1$ accordingly. For QCA it was already stated that the clock number $clk = 4$.\\
\end{definition}

From this definition we can outline the difficulty of placing and routing a logic network onto a two-dimensional grid, with exception of wire crossings, which however are really costly and therefore should be minimized. One major challenge for P\&R algorithms is the signal synchronization, which results in a strong dependency of clocking and signal distribution. As already pointed out, for every signal path it has to hold true that information can only propagate from a tile with clocking number $i$ to an outgoing tile with clocking number $(i+1 \mod clk)$. This property is called the \textit{local synchronization constraint}. The existence of possible signal paths can be assured by using predefined clocking schemes, but, however, can comprise some constraints. In addition, \textit{global synchronization constraint} states that every two signal paths leading to the same tile need to pass the same amount of tiles starting at their primary input. Since this constraint has to hold true for every gate, the complexity increases rapidly with growing network sizes. Therefore, the combination of all these challenges forms a P\&R problem, which is commonly accepted as $\mathcal{NP}$-complete \cite{NP-hard}. \\
After reaching a gate-level layout still a technology has to be mapped onto it. For this work the in subsection \ref{subsec:gates} proposed standard library is used for the mapping. Although the definitions in this work are quite generic because they are based on the book \cite{Walter}, defining the P\&R problem for the domain of field-coupled nanotechnologies. This means that, for example, a change of clock to $clk = 3$ also allows a placement and routing for \textit{Nanomagnet Logic} (NML). Even though the algorithm in this work is designed only for QCA, the ideas may also be derived for other FCN technologies.

\section{Sequentiality}\label{subsec:latchesandregisters}

The definition of the placement and routing problem is applicable for both combinational and sequential circuits. When treating the combinational logic as black-box, the outputs of it are storing the newly computed information into the registers and in the next cycle this information can be reused by connecting the registers again to the inputs of the combinational logic. This introduces a back-loop property, describing a signal propagating through combinational logic before being stored and stabilized by a register and being reused again. This back-looping represents the key property of sequential circuits.. In this section the implementation of storage elements in QCA is discussed, based on their properties derived from the CMOS domain.

\subsection{CMOS storage elements}
Assuming that cominational logic can be implemented in QCA, registers or rather storage elements in general leave to be discussed. As already mentioned their task is to stabilize and store information which is then looped back via wires. To get a better understanding of how they can be implemented in QCA, first their main characteristics have to be derived from the well-known CMOS technology. Due to the already shown basic differences in signal propagation and clocking between the two technology domains, it will become clear that the implementation of latches and registers also has to be rethought from scratch.

\begin{figure}
	\centering
	\begin{circuitikz}[american] \draw
		(1,0) node[not port] (not1) {}
		(1,-2) node[not port, rotate = 180] (not2) {}
		(-1,0) -- (0, 0)
		(0,0) -- (not1.in)
		(not1.out) -- (2, 0)
		(2, 0) -- (3, 0)
		(2, 0) -- (2, -2)
		(2, -2) -- (not2.in)
		(not2.out) -- (0, -2)
		(0, -2) -- (0, 0)
		
		(0.5,0) node [anchor=west] {$1$}
		(1.5,-2) node [anchor=east] {$2$}
		(-2, 0) node [anchor=west] {$in$}
		(4, 0) node [anchor=east] {$out$}
		(-2, -1) node [anchor=west] {$V_{o1}=V_{i2}$}
		(4, -1) node [anchor=east] {$V_{o2}=V_{i1}$}
		;
	\end{circuitikz}
	\caption{Eccles-Jordan-Flip-Flop}\label{fig:EJFF}
\end{figure}

The simplest storage element in CMOS, which can store one bit, is the so-called Eccles-Jordan \text{flip-flop} (FF). It is formed by connecting the output of one inverter to the input of another inverter and vice versa. Therefore the logic level is propagated from one inverter stage to the other, while the same value is held in it. Due to its simplicity, a high voltage shift is needed in order to change its stored value, making the FF really sluggish.

Also the direct connection of the input and output makes their voltage levels highly dependent on each other, which can be interpreted as noisy behavior, also referred to as \text{transparency} \cite{hawkins2012cmos}. To avoid errors caused by the transparent behavior in the transition region, the input voltage needs to be really stable. In order to receive more robust storage elements, more sophisticated ideas were implemented while preserving the general idea introduced by the EJ-FF.

By replacing the inverters in a EJ-FF with NOR gates, the transparency gets reduced and two inputs a set $S$ and a reset $R$ are introduced leading to four possible input combinations and clear states. When both $S=0$ and $R=0$, the current value is latched and the storage element is in the hold state. By holding $R=0$ and changing $S=1$, the latch output is forced to $Q=1$, called the set state. Reversing both inputs to $R=1$ and $S=0$ leads to the reset state where the latch output is $Q=0$. Furthermore, with $S, R = 1$, the latch value is unstable, and therefore we get an undefined state, prohibiting this input combination. Based on its behavior, this element is called \textit{Set-Reset-Latch} (SR-Latch).

\begin{figure}
	\centering
	\begin{minipage}{0.35\textwidth}
		\begin{circuitikz}[american] \draw
			(0,2) node[nor port] (NOR1) {}
			(1,2) node[anchor=east] {Q}
			(1,0) node[anchor=east] {$\overline{Q}$}
			(0,0) node[nor port] (NOR2) {}
			(NOR1.in 1) node[anchor=east] {R}
			(NOR2.in 2) node[anchor=east] {S}
			(NOR1.out) -- ++(0,-0.5) -- ($(NOR2.in 1) +(0,0.5)$) -- (NOR2.in 1)
			(NOR2.out) -- ++(0,+0.5) -- ($(NOR1.in 2) +(0,-0.5)$)--(NOR1.in 2)
			;
		\end{circuitikz}
	\end{minipage}
	\begin{minipage}{0.35\textwidth}
		\begin{tabular}{| c | c | c | c |}
			\hline
			\textbf{S} & \textbf{R} & \textbf{$Q_{next}$} & \textbf{State}\\
			\hline
			0 & 0 & Q & hold state\\
			\hline
			0 & 1 & 0 & reset\\
			\hline
			1 & 0 & 1 & set\\
			\hline
			1 & 1 & X & undefined state\\
			\hline
		\end{tabular}
	\end{minipage}	
	\caption{SR-Latch}\label{fig:SR-Latch}
\end{figure}

Because in QCA we only discuss synchronous logic, we also need to make this latch synchronous by clocking the Set and Reset inputs resulting in a gated SR-Latch. To eliminate the undefined state, the set and inverted reset inputs are connected together, forming the D-Latch. Now a value is held when the clock $clk=0$ and the D lock propagates the input value $D$ when $clk=1$. To give a memory element the ability to clock Boolean operations from one stage to another, \textit{edge triggered} flip flops are introduced . Rising clock edges determine when the FF overwrites and passes its data. An edge-triggered D-FF can be constructed by connecting two D-latch stages behind each other. The master slave is activated at rising edges, while the slave stage is activated at falling clock edges. In this way, the D-FF takes new data at a rising edge and passes them in the next clock cycle from its output. Also, the master-slave principle eliminates the transparency. Regarding the term edge-sensitive for D-FFs, latches are considered to be level-sensitive \cite{hawkins2012cmos}.\\

\begin{figure}
	\centering
	\begin{minipage}{0.5\textwidth}
		\begin{circuitikz}[american] \draw
			% Draw and gates
			(0,2) node[and port] (and1) {}
			(0,0) node[and port] (and2) {}
			
			% Draw nor gates
			(and1.out) -- ++(0.25,0) node
			[
			nor port,
			anchor=in 1
			] (nor1) {}
			
			(and2.out) -- ++(0.25,0) node
			[
			nor port,
			anchor=in 2
			] (nor2) {}
			
			(nor1.in 2) -| ++ (-0.3,-0.25) -- ++(2,-0.5) coordinate(a) |- (nor2.out)
			(nor2.in 1) -| ++ (-0.3,0.25) -- ++(2,0.5) |- (nor1.out)
			
			% Clock
			(and1.in 2) -- (and2.in 1)node[midway](clk){}
			(clk.center) -- ++(-1.25,0) node[left]{Clk}
			
			% Output labels
			(nor1.out -| a) -- ++(0.75,0) node[right]{$Q$}
			(nor2.out -| a) -- ++(0.75,0) node[right]{$\overline{Q}$}
			
			(and2.in 2) -- ++(-1.25,0) coordinate(a2) node[left=0.1cm]{D}
			
			% Not port
			(-1.9,0.2) node
			[
			not port,
			rotate=90,
			scale=0.5,
			](not) {}
			
			(not.in) |- (a2) (not.out) |- (and1.in 1)  
			;
		\end{circuitikz}
	\end{minipage}
	\begin{minipage}{0.4\textwidth}
		\begin{tabular}{| c | c | c | c |}
			\hline
			\textbf{clk} & \textbf{D} & $Q_{next}$ & \textbf{State}\\
			\hline
			0 & 0 & * & hold state\\
			\hline
			0 & 1 & 0 & propagate\\
			\hline
			1 & 0 & 1 & propagate\\
			
			\hline
		\end{tabular}
	\end{minipage}	
	\caption{D-Latch}\label{fig:D-Latch}
\end{figure}

\subsection{QCA storage elements}

The goal of a storage element in QCA is to have all the properties of a D-FF, so it can store data from one clock cycle and pass it to the combinational logic in the next clock cycle. Also the element should not be transparent and the effect of an edge triggered element has to be discussed. In the QCA ONE library an effort was made to translate the D-FF into QCA by just replacing the CMOS gates and wires with the corresponding QCA gates. Thus a second external $clk$ signal is introduced, mimicking the clock of a CMOS circuit. But since the QCA circuit already has its own clock with a dependency on all gates of the circuit and the clocking has some major differences from QCA to CMOS, as already observed in \ref{subsec:clocking}, this implementation is questionable.\\

\begin{figure}
	\begin{tikzpicture}
		
		% horizontal axis
		\draw[->] (0,0) -- (14,0) node[anchor=north] {$t$};
		
		% vertical axis
		\draw[->] (0,0) -- (0,1.5) node[anchor=east] {$E_{clock4}$};
		% nominal speed
		\draw[dotted] (2,0) -- (2,1.4);
		\draw[dotted] (4,0) -- (4,1.4);
		\draw[dotted] (6,0) -- (6,1.4);
		\draw[dotted] (8,0) -- (8,1.4);
		\draw[dotted] (10,0) -- (10,1.4);
		\draw[dotted] (12,0) -- (12,1.4);
		
		% Us
		\draw[thick] (0,0) -- (2,1.3) -- (4,1.3) -- (6,1.3) -- (8,1.3) --  (10,1.3) -- (12, 1.3) -- (14, 0);
		\draw (1,1.4) node {}; %label
		\draw (1,1) node [rotate = 32] {$switch$};
		\draw (7,1) node [] {$hold$};
		\draw (13,1) node [rotate = -32] {$release$};
		
	\end{tikzpicture}
	\begin{tikzpicture}
		
		% horizontal axis
		\draw[->] (0,0) -- (14,0) node[anchor=north] {$t$};
		
		% vertical axis
		\draw[->] (0,0) -- (0,1.5) node[anchor=east] {$E_{clock4}$};
		% nominal speed
		\draw[dotted] (2,0) -- (2,1.4);
		\draw[dotted] (4,0) -- (4,1.4);
		\draw[dotted] (6,0) -- (6,1.4);
		\draw[dotted] (8,0) -- (8,1.4);
		\draw[dotted] (10,0) -- (10,1.4);
		\draw[dotted] (12,0) -- (12,1.4);
		
		% E
		\draw[thick] (0,0) -- (2,1.3) -- (4,1.3) -- (6,0) -- (8,0) --  (10,1.3) -- (12,1.3) -- (14,0);
		\draw (1,1.4) node {}; %label
		\draw (1,1) node [rotate = 32] {$switch$};
		\draw (3,1) node [] {$hold$};
		\draw (5,1) node [rotate = -32] {$release$};
		\draw (7,0.3) node [] {$relax$};
		\draw (9,1) node [rotate = 32] {$switch$};
		\draw (11,1) node [] {$hold$};
		\draw (13,1) node [rotate = -32] {$release$};
	\end{tikzpicture}
	\caption{Clocking of a basic latch in QCA}\label{fig:sequ_el_clocking}
\end{figure}

This leads us to ideas to look at QCA storage elements dependent on their corresponding clocking.
The effort of rethinking storage elements in QCA from scratch was already made in \cite{torres2018synchronization}. The proposed solution to create a QCA element which is able to store one bit is rather simple. Since every tile is clocked on its own, a simple latch can be formed by a wire segment held in the hold phase of the clocking. In Figure \ref{fig:sequ_el_clocking} the clocking of this wire segment is depicted. The data is propagating into the latch and by holding the hold phase by exactly one clock cycle the data is passed to the next logic block exactly one clock cycle later. Also the question arises if this element is a level-sensitive latch or if it is a edge-sensitive FF. For the latch we could argue that the information is clearly not sampled at one time point like in an ideal FF, but rather the information is taken into the latch during the whole switch phase. On the other hand one could argue that the switch phase could be seen like a real-time rising clock edge, where the data is sampled and then held while the clock is in hold phase or "1". For this work, the comparison to a FF seems to be more suited because also no transparency is allowed due to the strictly independent clocked tiles in QCA. The only functionality the wire-FF misses is a set-reset option. The idea for this was also proposed in \cite{Walter} by exchanging the wire with a majority gate but the same clocking. Now the D-FF basically has the same functionality but has two external inputs which can force the gate to zero by setting both inputs to zero or force the gate to one by setting both inputs to one. In the other configurations, the majority-FF would act as normal storage element.\\

Further the idea of an FF wire should be discussed in the domain of placement and routing and not only as a single element. First of all it can be examined that the proposed FF implementation requires more complex clock generators for every latch, and it is not sure if this is possible to implement. Also if we look back at the analogy of CMOS have now a combinational logic block and our storage element formed by a wire FF. But there is still a big difference. While in CMOS the information can just be arbitrarily wired back from the storage to the inputs of the combinational logic, in QCA the wiring back implies the placement of wire segments of which each is delaying the information by one clocking zone already. When looking back to the functionality of a storage element, it can be found that this delay is exactly the purpose of a clocking element. The idea proposed in this work is now to use the delay, which occurs naturally due to sequential wiring to mimic storage elements.
Figure \ref{fig:sequential_gate_sample} shows a schematic of a sequential circuit with combinational logic and the wiring that results from the need for a back loop. At the output of the combinational logic there are the normal primary outputs and also register inputs. The register inputs are then wired to the corresponding register outputs, which are treated as the primary input of the next cycle of the circuit. Because the information needs additional clock cycles to pass through the register, the throughput of the logic is slowed. But since the loop has to be closed, this slow-down cannot be prevented in QCA following this approach.
%D-latch can be used to delay time by the circuit frequency

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance={2cm and 2cm}, thick, main/.style = {draw, rectangle}] 
		\node[fit={(0,0) (8, 8)}, inner sep=0pt, draw=black, thick] (frame) {};
		\node[fit={(2,2) (6, 8)}, inner sep=0pt, draw=black, thick, fill=cyan] (logic) {Combinational logic};
		\node[fit={(1,6.5) (2, 8)}, inner sep=0pt, draw=black, thick, fill=TUMGray] (PIs) {PIs};
		\node[fit={(1,5) (2, 6.5)}, inner sep=0pt, draw=black, thick, fill=lightgray] (ROs) {ROs};
		\node[fit={(6,3.5) (7, 5)}, inner sep=0pt, draw=black, thick, fill=TUMGray] (POs) {POs};
		\node[fit={(6,2) (7, 3.5)}, inner sep=0pt, draw=black, thick, fill=lightgray] (RIs) {RIs};
		
		
		\draw[] (7, 3.5) -- (8, 3.5);
		\draw[] (0, 6.5) -- (1, 6.5);
		\draw[fill=Apricot] (0, 0) -- (0, 6.5) -- (1, 6.5)  -- (1, 5) -- (2, 5) -- (2, 2) -- (7, 2) -- (7, 3.5) -- (8, 3.5) -- (8, 0) -- (0, 0);
		\draw (4,1) node [align=left] {Sequential wires from Ris to Ros \\ with delay of $c$ clock cycles};
		%		\draw[->] (2) -- (5);
		%		\draw[->] (3) -- (6);
		%		\draw[->] (4) -- (6);
		%		\draw[->] (5) -- (7);
		%		\draw[->] (6) -- (7);
		%		\draw[->] (7) -- (f);
		
	\end{tikzpicture} 
	\caption{Scheme of a sequential circuit layout after placement and routing} \label{fig:sequential_gate_sample}
\end{figure}

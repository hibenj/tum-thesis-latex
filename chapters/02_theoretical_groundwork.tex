\chapter{Preliminaries}\label{chapter:Preliminaries}

\section{Representation of Logic Circuits}
The Boolean Algebra, formed by mathematician George Boole in 1847, shows that every digital circuit can be represented by logic functions, independent of their underlying technology. Until today his work is the foundation for defining and discussing about them.

\subsection{Boolean Functions}\label{subsec:boolfunc}
A definition of the Boolean calculus was first provided by Edward V. Huntington in 1993. From the \textit{set of independent postulates for the algebra of logic} and his own correction \cite{HuntingtonPostulate, HuntingtonCorrection}, the following equations form the basis of every boolean algebra:

\begin{definition}[Basis for Boolean algebra]\label{Def:BasBool}
Let $a, b, c$ be arbitrary elements of an abstract algebra $(L, +, ')$ with their set denoted as $B_{abs}$. The algebra includes the binary function $+ : B_{abs} \times B_{abs} \rightarrow B_{abs}$ and the unary function $' : B_{abs} \rightarrow B_{abs}$.
\begin{table}[h]
	\centering
	\begin{tabular}{c}
		$a + b = b + a$ \\
		$(a + b) + c =  a + (b + c)$\\
		$(a' + b')' + (a' + b)' = a$\\
	\end{tabular}
\end{table}

The last of his postulates named after the inventor and is commonly known as \textit{Huntington equation}. Also it exists an "universe" element $u \in B_{abs}$ for which holds:

\begin{table}[h]
	\centering
	\begin{tabular}{l}
		$\exists u' : a + u' = a$ \\
		$\exists u : a + a' = u$. \\
	\end{tabular}
\end{table}

\end{definition}

The most common Boolean algebra $\mathbb{B}$ is defined by the 6-tuple $(\mathbb{B}, \vee, \wedge, \neg, 0, 1)$, where $\vee$ and $\wedge$ are another denotations for the binary operands for disjunction $+$ and conjunction $\cdot$ in $\mathbb{B}$. The third function $\neg$ describes the unary negotiation function, which was former denoted as $'$. The set $\mathbb{B}$ holds two distinct elements $\{0, 1\}$, with $u=1$ and $\neg u = 0$ respectively \cite{Boolean_def}.\\

Since this definition is restricting the use of only the three Boolean functions $(\vee, \wedge, \neg)$, we want to extend it by the following definition \cite{muti_output_boolean_function}:

\begin{definition}[Boolean function]
A Boolean function can be described as f : $\{0, 1\}^k \to \{0, 1\}$, with $k \in \mathbb{N}^*$ being the functions number of arguments or arity. A function with $k$ arguments is referred to as $k$-ary. Multi-output Boolean functions can be described as $\{0, 1\}^k \to \{0, 1\}^m$, with the integer $m > 0$.
\end{definition}

Nonetheless, every $k$-ary function can still be decomposed into a set of the common Boolean functions $(\vee, \wedge, \not)$.
A common notation for Boolean functions are the \textit{conjunctive normal form} (CNF) and \textit{disjunctive normal form} (DNF), using literals.

\begin{definition}
	A literal is either an atom $a$ (positive literal) or the negation of an atom $\neg a$ (negative literal).
\end{definition}

\begin{definition}
A propositional Boolean formula is said to be in CNF if it is a conjunction of \textit{clauses}, each of which is a disjunction of literals \cite{CNF}:\\
\[\displaystyle\bigwedge_{i} \displaystyle\bigvee_{j} (\neg) v_{ij}, \]
where $v_{ij} \in \mathbb{B}$.\\
A propositional Boolean formula is said to be in DNF if it is a disjunction of clauses, each of which is a conjunction of literals:\\
\[ \displaystyle\bigvee_{i} \displaystyle\bigwedge_{j} (\neg) v_{ij}, \]
where $v_{ij} \in \mathbb{B}$.

\end{definition}

Using the CNF or rather the DNF and \textit{De Morgan's laws} following from the definitions in \ref{Def:BasBool}, it follows that any Boolean Algebra can be reduced to only two operands, e.g. conjunction ($\vee$) and negation ($\neg$). Any set of such two Boolean functions is called \textit{universal}.


\subsection{Logic Networks}

There are many ways of representing Boolean Functions. But most of them, including e.g. truth tables or reduced sum of products, suffer from drawbacks like exponential representations of basic functions like the parity (XOR) function. Even if a reasonable representation exists for a given function, simple operations like forming the complementary could yield an exponential function representation. Logic networks overcome these restrictions and have proven to be very useful transforming a circuit described by logic functions into a gate representation. This process is also referred to as \textit{logic synthesis}. An approach for logic networks is given in \cite{LogicNetwork}, describing \textit{function graphs}:

\begin{definition}[Function graph]
	A function graph is a rooted, directed graph with vertex set $V$ containing two types of vertices. A \textit{nonterminal} vertex $v$ has as attributes an argument index $index(v) \in \{1, . . .,n\}$, and two children $low(v),high(v) \in V$. A \textit{terminal} vertex v has as attribute a value $value(v)\in\{0,1\}$.\\
	\\
	Furthermore, for any nonterminal vertex $v$, if $low(v)$ is also nonterminal, then we must have
	$index(v) < index(low(v))$. Similarly, if $high(v)$ is nonterminal, then we must have
	$index(v) < index(high(v))$.
\end{definition}

\begin{definition}[Function Graph Boolean Functions]
	A function graph $G$ having root vertex $v$ denotes a function $f_v$ defined recursively as:
	\begin{enumerate}
		\item If v is a terminal vertex:
		\begin{enumerate}
			\item If $value(v)=1$, then $f_v=1$
			\item If $value(v)=0$, then $f_v=0$
		\end{enumerate}
		\item If $v$ is a nonterminal vertex with $index(v)=i$, then $f_v$ is the function \\ 
		$f_v(x_1, ..., x_n) = \bar{x}_i \cdot f_{low(v)}(x_1, ..., x_n) + x_i \cdot f_{high(v)}(x_1, ..., x_n)$.
	\end{enumerate}
\end{definition}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance={2cm and 2cm}, thick, main/.style = {draw, circle}] 
		\node[main] (1) at (0,0) [label=west:$v_1$]{$I_1$}; 
		\node[main] (2) at (0,-2)[label=west:$v_2$] {$I_2$};
		\node[main] (3) at (0,-4)[label=west:$v_3$] {$I_3$};
		\node[main] (4) at (0,-6)[label=west:$v_4$] {$I_4$}; 
		
		\node[main] (5) at (2,-1)[label=north:$v_5$]{$\wedge$}; 
		\node[main] (6) at (2,-5)[label=north:$v_6$]{$\vee$};
		
		\node[main] (7) at (4,-3)[label=north:$v_7$]{$\vee$};
	
		\node [right of = 7] (f) {$f_v$};
		
		
		\draw[->] (1) -- (5);
		\draw[->] (2) -- (5);
		\draw[->] (3) -- (6);
		\draw[->] (4) -- (6);
		\draw[->] (5) -- (7);
		\draw[->] (6) -- (7);
		\draw[->] (7) -- (f);
		
	\end{tikzpicture} 
	\\
	\hfill \break
	The corresponding recursive Boolean function reads:\\
	\hfill \break
	\begin{tabular}{l l}
		
		$f_v = f_v(v_7)$ &  $f_v(v_6) = f_v(v_3) \wedge f_v(v_4)$\\
		$f_v(v_7) = f_v(v_5) \vee f_v(v_6)$ &  $f_v(v_5) = f_v(v_1) \vee f_v(v_2)$\\
		&\\
		with primary inputs: & 	$f_v(v_1), f_v(v_2), f_v(v_3), f_v(v_4) \in \{0, 1\}$\\
		&\\
	\end{tabular}
	
	\caption{Binary Logic Network} \label{fig:LNEx}
\end{figure}

Since the definition reduces the number of children connected to a vertex to two, therefore only  allowing binary Boolean Functions, a custom definition is given:

\begin{definition}[Logic Network]
	A logic network $N(V, E)$ is a rooted, directed graph with vertex set $V$ and edge set $E$. For any vertex $v \in V$, vertices connected by incoming edges $e_{inc} \in E$ are called children. A vertex connected by and outgoing edge $e_{out} \in E$ is called parent.
	$V$ contains two types of vertices. A \textit{nonterminal} vertex $v$ has as attributes an argument index $index(v) \in \{1, . . .,n\}$, and $l$ children $child_1(v), ..., child_l(v) \in V$. 
	A \textit{terminal} vertex v has as attribute a value $value(v)\in\{0,1\}$.\\
	\\
	Furthermore, for any nonterminal vertex $v$, if $child_i(v)$ with $ 1 \leq i \leq l$, then we must have $index(child_i(v)) < index(v)$ respectively.
\end{definition}

\begin{definition}[Logic Network Boolean Functions]
	A set of nary Boolean Functions $x_1, ..., x_n \in \mathbb{B}$ is assigned to every vertex via the argument index $index(v) = i$. The graph function $f_v$ is defined recursively as:
	\begin{enumerate}
		\item If v is a terminal vertex:
		\begin{enumerate}
			\item If $value(v)=1$, then $f_v=1$
			\item If $value(v)=0$, then $f_v=0$
		\end{enumerate}
		\item If $v$ is a nonterminal vertex with $index(v)=i$, then $f_v$ is the function \\ 
		$f_v(v_i) = x_i(f_{child_1(v)}(v_{i-1}), ..., f_{child_l(v)}(v_{i-n}))$.
	\end{enumerate}
\end{definition}

The recursive nature of the Boolean Function definition in logic networks can be seen in \ref*{fig:LNEx}.

\begin{definition}[Majority Function]\label{Def:majf}
	The ternary Boolean majority function is defined as: $\langle a, b, c \rangle = ab + ac + bc$, so that the function value equals the majority of it's incoming values.\\
	It follows: $\langle a, b, 0 \rangle = a \cdot b$ and $\langle a, b, 1 \rangle = a + b$.
\end{definition}

Adapting the names used in the underlying libraries used to program the algorithms proposed subsequently following in this work (chapter \ref{chapter:Methodology}), a terminal vertex is referred to as \textit{primary input} (PI) with their set denoted as $I$. The set of nonterminal vertices referred to as \textit{nodes} is denoted as $\Lambda$. From the definition follows $I \cap \Lambda = \emptyset$. An edge connecting a children $\nu_i$ and parent vertex $\nu_j$ is called a \textit{signal}. With $i < j$ the notation of a signal is given as $(\nu_i, \nu_j)$. The set of all signals is denoted as $\Sigma$. If an edge is dangling, so it doesn't point to another vertex, it is called \textit{primary output} (PO) and their set is denoted as $O$. Therefore also $\Sigma \cap O = \emptyset$ holds true. From the definition of a logic network we can now describe it as acyclic directed graph $N = (\Lambda, I, \Sigma, O)$.\\
As already mentioned in subsection \ref{subsec:boolfunc}, a universal set of two Boolean functions can form any Boolean algebra.
As long as this universality is contained the set of node functions in a logic network can be extended arbitrarily. Common logic networks containing only two network functions are e.g. \textit{AND-Inverter Graphs} (AIGs) allowing only conjunction and negation. Another widely used binary logic network is the \textit{Majority-Inverter Graphs} (MIGs) utilizing the ternary majority function and negation. But there also exists a wide range of logic networks permitting more than just two node functions. One widely used example is the \textit{XOR-AND-Inverter Graph} (XAG) with the parity function, conjunction and negation functions respectively.\\

As part of the logic synthesis, a suitable logic network representation of the combinational circuit has to be determined. Because, even though these logic networks can implement any Boolean function given in a specification, not every logic network can be synthesized into any given technology.
Looking at the current standard technology \textit{complementary metal-oxidesemiconductor} (CMOS), the logic network is then synthesized by using building blocks consisting of \textit{metal-oxide-semiconductor field-effect transistors} (MOSFETs), the elemental unit in this technology.\\

One drawback, that sticks to this definition of logic networks and holds also true for the aforementioned representations is that they are all \textit{non-canonical}, which means that a given function can be represented by different logic networks. This property can be explained by the fact that nodes with the identity function are allowed, which can be inserted everywhere in the logic network, while the function representation of the logic network stays the same. Even the exclusion of such identity nodes has no impact, since simple node combinations, like two negotiation nodes, collapse to the identity function. Following this argumentation, there exists an infinite number of logic networks representing one Boolean Function, resulting in the widely accepted assumption, that the determination of an optimal logic network is a $\mathcal{NP}$-complete problem \cite{Walter}. Attempts to create canonical logic networks, seem to evade this problem, but include co$\mathcal{NP}$-complete problems in itself \cite{LogicNetwork}. Algorithms used for logic synthesis are therefore based on approximate solutions .


\section{QCA Technology}

Following the well known Moores law, CMOS technology is facing a multitude of challenges. Well-known are e.g. short channel effect, impurity variations, and most importantly the heat, resulting from static and dynamic power losses. To tackle these challenges the International Roadmap for Devices and Systems (IDRS), former ITRS, proposes solutions within the semiconductor domain, e.g. new materials and multi-core architectures. But also new technologies are researched including Quantum computing and the domain of \textit{Field-Coupled Nanocomputing} (FCN). This work focuses on one of the most promising FCN technologies, namely \textit{Quantum dot cellular automata} (QCA). The main difference of this technology compared to CMOS is the representation of logical modes, using the location of electron pairs in QCA-cells, instead of voltage levels. Data between cells is transferred based on Coulomb repulsion, utilizing electromagnetic fields. This enables the technology to achieve high performance in terms of device density, clock frequency and power consumption \cite{mohammadi2016efficient}.

\subsection{Cells}
As already mentioned, the elemental unit of this technology is a QCA-cell. Since there in no uniform way of build the quantum dots and connecting them to cells, we look at a rather lower-level abstraction depicted in figure \ref{fig:QCAStates}. The four circles in the corners of the QCA-cells show quantum-dots, that can be implemented by any charge container with discrete electrical energy states. Further a cell contains two excess electrons, which can be localized by the quantum dots. The energy barriers or the quantum dots are able to trap the charge of the electron. If an electron is trapped inside a quantum-dot it is filled black. Due to the Coulomb repulsion the electrons occupy diagonally opposed quantum dots, resulting in two possible stable cell configurations and one unstable cell configuration \cite{Sasamal2020QuantumDotCA, lent1997device, lent1994quantum}.\\
A stable states indicates, that it is well distinguishable of the usual energy band. Therefore the energy difference between two consecutive energy states must be well above the thermal noise energy ($k_BT$). Only such states are suited for information transfer. The stable states can be derived from the cell Polarization, which can be $+1$ and $-1$ or $null$ in the unexcited state. The two stable states contain the same electrostatic energy and are used to encode the binary values $0$ and $1$ \cite{Sasamal2020QuantumDotCA}.\\
In order to transfer information, cells are placed side by side, whereby the polarization of the driver cell, which is the left most cell inputting the information, changes the polarization of the adjacent cell. When the adjacent cell is polarized it can give its state to the next cell and so on \cite{lent1997device}. This simple structure is representing a wire in QCA-technology and its function is depicted in Figure \ref{fig:QCAWire}.

\begin{figure}
	\centering
	\begin{tikzpicture}
		%One QCA-Cell
		\node (A1) at (0.6,1.5) {$0$};
		\draw[rounded corners] (0, 0) rectangle (1.2, 1.2) [label=north:$v_7$]{};
		\node (A2) at (0.6,-0.3) {$P = -1$};
		
		\draw (0.3,0.3) circle (2mm);
		\draw [fill = black] (0.9,0.3) circle (2mm);
		\draw [fill = black](0.3,0.9) circle (2mm);
		\draw (0.9,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{2}
		\node (B1) at (0.6+\x,1.5) {$1$};
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\node (B2) at (0.6+\x,-0.3) {$P = +1$};
	
		\draw [fill = black] (0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black] (0.9+\x,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{4}
		\node (C1) at (0.6+\x,1.5) {$null$};
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\node (C2) at (0.6+\x,-0.3) {$P = 0$};
		
		\draw (0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw (0.9+\x,0.9) circle (2mm);
		
		
	\end{tikzpicture} 

	\caption{QCA-Cell sates} \label{fig:QCAStates}
\end{figure}

\begin{figure}
	\centering
	\begin{tikzpicture}
		%One QCA-Cell
		\node (A1) at (-0.3,0.6) {$1$};
		\draw[rounded corners] (0, 0) rectangle (1.2, 1.2) [label=north:$v_7$]{};
		
		\draw [fill = black](0.3,0.3) circle (2mm);
		\draw (0.9,0.3) circle (2mm);
		\draw (0.3,0.9) circle (2mm);
		\draw [fill = black](0.9,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{1.2}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		
		\draw [fill = black] (0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black] (0.9+\x,0.9) circle (2mm);
		
		
		%One QCA-Cell
		\def\x{2.4}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\draw [fill = black](0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black](0.9+\x,0.9) circle (2mm);
		
		%One QCA-Cell
		\def\x{3.6}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\draw [fill = black](0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black](0.9+\x,0.9) circle (2mm);
		
		%One QCA-Cell
		\def\x{4.8}
		\draw[rounded corners] (\x, 0) rectangle (1.2 + \x, 1.2) {};
		\draw [fill = black](0.3+\x,0.3) circle (2mm);
		\draw (0.9+\x,0.3) circle (2mm);
		\draw (0.3+\x,0.9) circle (2mm);
		\draw [fill = black](0.9+\x,0.9) circle (2mm);
		\node (C1) at (1.5+\x,0.6) {$1$};
		
		
	\end{tikzpicture} 
	
	\caption{Adjacent QCA-cells forming a wire segment} \label{fig:QCAWire}
\end{figure}

\subsection{Clocking}\label{subsec:clocking}

As already mentioned, the data transfer in the QCA paradigm is accomplished by cell-to-cell interaction. Given a fixed polarization of a cell, the next cell reacts to the Coulomb repulsion and changes its polarization accordingly. Looking at the wire segment in figure \ref{fig:QCAWire},
the leftmost cell has a fixed polarization and is called the input. After some time the information propagates through to the right most cell, representing the output of the simplified QCA-circuit. The depicted state of the cell, where all neighboring cells have the same polarization is called ground state. Since the logic is deterministic, there exists exactly one ground state configuration of cell polarization for one choice of inputs. When in ground state, the circuit has minimum state energy.

Given a circuit in ground state, when the input of the system is changed, the systems energy rises as depicted in figure \ref{fig:info_pass}. It results from the so called \textit{kink}-energy, which describes the energy difference between two QCA-cells with opposing polarization. Since the polarization of the cells changes one cell after the other, also the \textit{kink} moves along the cells. After time $\tau$ the system dissipates again into the ground state, with newly computed outputs. While the kink-energy stays the same with an increasing number of cells, degeneracy of the excited states rises. This again means, that the system can be illegally in an excited state at non-zero temperature \cite{lent1994quantum}.\\

The described process is called abrupt switching with dissipative coupling to the environment and can be summarized in the following three steps \cite{lent1994quantum}:
\begin{enumerate}
	\item Write the input bit by fixing the polarization state of
	cells along the input edge.
	\item Allow the array to relax to its ground state while the
	new inputs are kept fixed.
	\item Non-invasively read the results of the computation
	by sensing the polarization state of cells.
	%this is just copied
\end{enumerate}

In the second step, highly complex dissipation mechanisms like phonon and plasmon emission take place, making it nearly impossible to get a complete theoretical description of the system. The dissipation time $\tau$ is therefore determined via experiments.\\
The first and third step require an environment, which provides the features for fixing inputs and sensing the output polarization. Such a system has to be integrated with classical CMOS devices as seen in Figure \ref{fig:QCA_array}.\\

\begin{figure}
	\centering
	\includegraphics[scale=0.6]{QCA_array}
	\caption{Schematic of a combined QCA and CMOS sytem \cite{lent1994quantum}.} 
	\label{fig:QCA_array}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[scale=0.6]{information_passing}
	\caption{Schematic representation of a metastable state. Instead
		of relaxing correctly to the new ground state, a system may be
		delayed in an excited state due to an inability to tunnel through a
		kinetic barrier \cite{lent1997device}.} 
	\label{fig:info_pass}
\end{figure}

In order to implement a full QCA-system without CMOS-components, the QCA-Array has to be divided into smaller decoupled sub-regions. Therefore an adiabatic switching or rather a clocking is introduced. The clocked regions are referred to as clocking zones. The clocking utilizes an external signal, the clock, to activate and deactivate said clocking zones. The approach first used, decreases the interdot barriers of all cells in a clocking zone, when applying a new input. When all cells in the region are stable, the barriers are raised again, while the barriers of the subsequent clocking zone are lowered simultaneously. This way the ground state gradually propagates through the whole circuit \cite{lent1997device}. Today's used approaches create electrical fields with an external clock generator and distribute it to the cells through the device substrate using embedded electrodes. Thereby the energy level of the \textit{null} state can be controlled, resulting in a equivalent effect as in the former approach \cite{Walter}.\\

A wire, divided in such clocking zones is shown in \ref{fig:QCAWire}. The colors of the zones and cells as well as the zone number show redundant information about the type of clocking zone. They differ in the external applied electrical field and therefore the energy of the cells. In QCA the clocking is divided into the four consecutive states, \textit{switch}, \textit{hold}, \textit{release} and \textit{relax}. They are aligned in a pipeline like structure, where each of these state is phase shifted by $\pi/2$, forming a $2\pi$ clock cycle. In the switch-phase cells start getting polarized dependent on the polarization of the driving cell. When the cells are polarized they get fixed in the hold-phase. Afterwards in the release-phase the excitation gradually decreases, resulting in the unexcited relax-state \cite{Sasamal2020QuantumDotCA}. The scheme of such a pipeline like clocking is depicted exemplary on a wire segment in Figure \ref{fig:QCAClockpipeline}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\centering
\tikzset{
	pics/cico/.style args={#1/#2/#3}{
		code = {
			\draw[rounded corners = 0.3mm] (#2 , #3) rectangle (1.2/3 + #2, 1.2/3 +#3){};
			\draw[fill = #1](0.3/3+ #2 ,0.3/3+ #3) circle (0.65mm);
			\draw (0.9/3+ #2 ,0.3/3+ #3) circle (0.65mm);
			\draw (0.3/3+ #2 ,0.9/3+ #3) circle (0.65mm);
			\draw[fill = #1] (0.9/3+ #2 ,0.9/3+ #3) circle (0.65mm);
}}}
\begin{tikzpicture}
	
	% horizontal axis
	\draw[->] (0,0) -- (10,0) node[anchor=north] {$t$};
	
	% vertical axis
	\draw[->] (0,0) -- (0,1.5) node[anchor=east] {$E_{clock1}$};
	% vertical lines
	\draw[dotted] (2,0) -- (2,1.4);
	\draw[dotted] (4,0) -- (4,1.4);
	\draw[dotted] (6,0) -- (6,1.4);
	\draw[dotted] (8,0) -- (8,1.4);
	
	% E
	\draw[thick] (0,0) -- (2,1.3) -- (4,1.3) -- (6,0) -- (8,0) --  (10,1.3);
	\draw (1,1.4) node {}; %label
	\draw (1,1) node [rotate = 32] {$switch$};
	\draw (3,1) node [] {$hold$};
	\draw (5,1) node [rotate = -32] {$release$};
	\draw (7,0.3) node [] {$relax$};
\end{tikzpicture}

\begin{tikzpicture}
	
	% horizontal axis
	\draw[->] (0,0) -- (10,0) node[anchor=north] {$t$};
	
	% vertical axis
	\draw[->] (0,0) -- (0,1.5) node[anchor=east] {$E_{clock2}$};
	% nominal speed
	\draw[dotted] (2,0) -- (2,1.4);
	\draw[dotted] (4,0) -- (4,1.4);
	\draw[dotted] (6,0) -- (6,1.4);
	\draw[dotted] (8,0) -- (8,1.4);
	
	% Us
	\draw[thick] (0,0) -- (2,0) -- (4,1.3) -- (6,1.3) -- (8,0) --  (10,0);
	\draw (1,1.4) node {}; %label
	\draw (1,0.3) node [] {$relax$};
	\draw (3,1) node [rotate = 32] {$switch$};
	\draw (5,1) node [] {$hold$};
	\draw (7,1) node [rotate = -32] {$release$};
	
	
\end{tikzpicture}

\begin{tikzpicture}
	
	% horizontal axis
	\draw[->] (0,0) -- (10,0) node[anchor=north] {$t$};
	
	% vertical axis
	\draw[->] (0,0) -- (0,1.5) node[anchor=east] {$E_{clock3}$};
	% nominal speed
	\draw[dotted] (2,0) -- (2,1.4);
	\draw[dotted] (4,0) -- (4,1.4);
	\draw[dotted] (6,0) -- (6,1.4);
	\draw[dotted] (8,0) -- (8,1.4);
	
	% Us
	\draw[thick] (0,1.3) -- (2,0) -- (4,0) -- (6,1.3) -- (8,1.3) --  (10,0);
	\draw (1,1.4) node {}; %label
	\draw (1,1) node [rotate = -32] {$release$};
	\draw (3,0.3) node [] {$relax$};
	\draw (5,1) node [rotate = 32] {$switch$};
	\draw (7,1) node [] {$hold$};
	
\end{tikzpicture}

\begin{tikzpicture}
	
	% horizontal axis
	\draw[->] (0,0) -- (10,0) node[anchor=north] {$t$};
	
	% vertical axis
	\draw[->] (0,0) -- (0,1.5) node[anchor=east] {$E_{clock4}$};
	% nominal speed
	\draw[dotted] (2,0) -- (2,1.4);
	\draw[dotted] (4,0) -- (4,1.4);
	\draw[dotted] (6,0) -- (6,1.4);
	\draw[dotted] (8,0) -- (8,1.4);
	
	% Us
	\draw[thick] (0,1.3) -- (2,1.3) -- (4,0) -- (6,0) -- (8,1.3) --  (10,1.3);
	\draw (1,1.4) node {}; %label
	\draw (1,1) node [] {$hold$};
	\draw (3,1) node [rotate = -32] {$release$};
	\draw (5,0.3) node [] {$relax$};
	\draw (7,1) node [rotate = 32] {$switch$};
	
\end{tikzpicture}
	\caption{QCA clocking pipeline} \label{fig:QCAClockpipeline}
\end{figure}


The described clocking is named \textit{Landauer clocking}. The inventor Rolf Landauer himself pointed out the vast power dissipation of this clocking mechanism. This impairing property is already well known from the CMOS technology, resulting in several drawbacks including extreme cases of switched off chip areas referred to as dark silicon. One common approach in CMOS is the lowering of circuit frequency utilizing e.g. multi-chip architectures. To tackle this problem in the QCA domain, Landauer pointed out that the \textit{erase} function has to be eliminated from the clocking. This function is logically irreversible and describes the erasing of information in a clock zone, when passed to the next. He argues that every erased bit dissipates at least $k_BT\ln(2)$ in heat. Exemplary if a QCA-cell has size $1nm \times 1nm$ and operating frequency of $100 GHz$, the corresponding density of devices results to $10^{14}$ $cm^{-2}$. Further a dissipation of $0.1 eV$ per electron every clock cycle is assumed, resulting in a total power dissipation of 160 $kW$ $cm^{-2}$. This directly yields to the statement, that a device operating with this clocking would be inoperable (it would evaporate due to the heat) \cite{lent2006bennett}. The \textit{Bennet clocking} tackles exactly this problem by altering the timing of the clocking signals. Just as in the Landauer clocking the clocking-wave moves from left to right, but leaving no trailing edge, when information is passed. Instead the cells will be held in the excited state until the information propagates through the whole QCA-array. When the output was read, the excitation is released in reverse order resulting in no erase functions. This means, that this \textit{quasi-adiabatic} clocking leads to a minimal power dissipation but with two constraints. The effective clock rate is at least halved due to the additional backwards propagation and since only one signal vector can be transmitted through the system, the pipeline capabilities are reduced \cite{lent2006bennett}.\\
In order to apply Bennet clocking, it was already stated that the QCA-array has to be divided into clock zones. Allowing an arbitrary number of cells in one clock zone gives lots of freedom in designing clock zones with variable geometries. This clocking is referred to as \textit{cell-based} and increases the fabrication process due to its variety in clock zone geometries. Assuming the necessity of an uniform fabrication in order to fabricate circuits with millions of cells, this clocking gets infeasible for large circuits. Also the scheme supports clocking of single cells, which means that electrodes of the same size have to be fabricated. Since this is also not feasible, this design is obsolete.\\ 
In order to attain uniform clocking zones with a possible distribution of clocking signals, the \textit{tile-based} clocking is introduced. The approach of this design is to provide uniform square tiles of the size $3 \times 3$ or $5 \times 5$. For clocking tiles bigger than this, the information propagation was suggested to be erroneous, also following in an argument against cell-based clocking \cite{taucer2015consequences}.


\begin{figure}
	\newcommand*{\xMin}{0}%
	\newcommand*{\xMax}{4}%
	\newcommand*{\xMaxc}{3}%
	\newcommand*{\yMin}{0}%
	\newcommand*{\yMax}{4}%
	\newcommand*{\yMaxc}{3}%
	\subfigure[2DDWave]
	{
		\begin{tikzpicture}
			
			\foreach \i in {\xMin,...,\xMax} {
				\draw [very thin,gray] (\i,\yMin) -- (\i,\yMax)  node [below] at (\i,\yMin) {};
			}
			\foreach \i in {\yMin,...,\yMax} {
				\draw [very thin,gray] (\xMin,\i) -- (\xMax,\i) node [left] at (\xMin,\i) {};
			}
		
		
			\draw[fill=darkgray]  (0, 1) -- (1, 1) -- (1,0) -- (0,0) -- cycle;
			\draw[fill=white]  (1, 1) -- (2, 1) -- (2,0) -- (1,0) -- cycle;
			\draw[fill=lightgray]  (2, 1) -- (3, 1) -- (3,0) -- (2,0) -- cycle;
			\draw[fill=gray]  (3, 1) -- (4, 1) -- (4,0) -- (3,0) -- cycle;
			
			\draw[fill=gray]  (0, 2) -- (1, 2) -- (1,1) -- (0,1) -- cycle;
			\draw[fill=darkgray]  (1, 2) -- (2, 2) -- (2,1) -- (1,1) -- cycle;
			\draw[fill=white]  (2, 2) -- (3, 2) -- (3,1) -- (2,1) -- cycle;
			\draw[fill=lightgray]  (3, 2) -- (4, 2) -- (4,1) -- (3,1) -- cycle;
			
			\draw[fill=lightgray]  (0, 3) -- (1, 3) -- (1,2) -- (0,2) -- cycle;
			\draw[fill=gray]  (1, 3) -- (2, 3) -- (2,2) -- (1,2) -- cycle;
			\draw[fill=darkgray]  (2, 3) -- (3, 3) -- (3,2) -- (2,2) -- cycle;
			\draw[fill=white]  (3, 3) -- (4, 3) -- (4,2) -- (3,2) -- cycle;
			
			\draw[fill=white]  (0, 4) -- (1, 4) -- (1,3) -- (0,3) -- cycle;
			\draw[fill=lightgray]  (1, 4) -- (2, 4) -- (2,3) -- (1,3) -- cycle;
			\draw[fill=gray]  (2, 4) -- (3, 4) -- (3,3) -- (2,3) -- cycle;
			\draw[fill=darkgray]  (3, 4) -- (4, 4) -- (4,3) -- (3,3) -- cycle;
			
			\node[text=white] (A1) at (0.85,0.18) {$4$};
			\node[text=black] (A1) at (1.85,0.18) {$1$};
			\node[text=black] (A1) at (2.85,0.18) {$2$};
			\node[text=white] (A1) at (3.85,0.18) {$3$};
			
			\node[text=white] (A1) at (0.85,1.18) {$3$};
			\node[text=white] (A1) at (1.85,1.18) {$4$};
			\node[text=black] (A1) at (2.85,1.18) {$1$};
			\node[text=black] (A1) at (3.85,1.18) {$2$};
			
			\node[text=black] (A1) at (0.85,2.18) {$2$};
			\node[text=white] (A1) at (1.85,2.18) {$3$};
			\node[text=white] (A1) at (2.85,2.18) {$4$};
			\node[text=black] (A1) at (3.85,2.18) {$1$};
			
			\node[text=black] (A1) at (0.85,3.18) {$1$};
			\node[text=black] (A1) at (1.85,3.18) {$2$};
			\node[text=white] (A1) at (2.85,3.18) {$3$};
			\node[text=white] (A1) at (3.85,3.18) {$4$};
	
		
		\end{tikzpicture}
	\label{subfig:2DD}
	}
	\subfigure[USE]
	{
		\begin{tikzpicture}
			\foreach \i in {\xMin,...,\xMax} {
				\draw [very thin,gray] (\i,\yMin) -- (\i,\yMax)  node [below] at (\i,\yMin) {};
			}
			\foreach \i in {\yMin,...,\yMax} {
				\draw [very thin,gray] (\xMin,\i) -- (\xMax,\i)
				node [left] at (\xMin,\i) {};
			}
		\draw[fill=lightgray]  (0, 1) -- (1, 1) -- (1,0) -- (0,0) -- cycle;
		\draw[fill=white]  (1, 1) -- (2, 1) -- (2,0) -- (1,0) -- cycle;
		\draw[fill=darkgray]  (2, 1) -- (3, 1) -- (3,0) -- (2,0) -- cycle;
		\draw[fill=gray]  (3, 1) -- (4, 1) -- (4,0) -- (3,0) -- cycle;
		
		\draw[fill=gray]  (0, 2) -- (1, 2) -- (1,1) -- (0,1) -- cycle;
		\draw[fill=darkgray]  (1, 2) -- (2, 2) -- (2,1) -- (1,1) -- cycle;
		\draw[fill=white]  (2, 2) -- (3, 2) -- (3,1) -- (2,1) -- cycle;
		\draw[fill=lightgray]  (3, 2) -- (4, 2) -- (4,1) -- (3,1) -- cycle;
		
		\draw[fill=darkgray]  (0, 3) -- (1, 3) -- (1,2) -- (0,2) -- cycle;
		\draw[fill=gray]  (1, 3) -- (2, 3) -- (2,2) -- (1,2) -- cycle;
		\draw[fill=lightgray]  (2, 3) -- (3, 3) -- (3,2) -- (2,2) -- cycle;
		\draw[fill=white]  (3, 3) -- (4, 3) -- (4,2) -- (3,2) -- cycle;
		
		\draw[fill=white]  (0, 4) -- (1, 4) -- (1,3) -- (0,3) -- cycle;
		\draw[fill=lightgray]  (1, 4) -- (2, 4) -- (2,3) -- (1,3) -- cycle;
		\draw[fill=gray]  (2, 4) -- (3, 4) -- (3,3) -- (2,3) -- cycle;
		\draw[fill=darkgray]  (3, 4) -- (4, 4) -- (4,3) -- (3,3) -- cycle;
		
		\node[text=black] (A1) at (0.85,0.18) {$2$};
		\node[text=black] (A1) at (1.85,0.18) {$1$};
		\node[text=white] (A1) at (2.85,0.18) {$4$};
		\node[text=white] (A1) at (3.85,0.18) {$3$};
		
		\node[text=white] (A1) at (0.85,1.18) {$3$};
		\node[text=white] (A1) at (1.85,1.18) {$4$};
		\node[text=black] (A1) at (2.85,1.18) {$1$};
		\node[text=black] (A1) at (3.85,1.18) {$2$};
		
		\node[text=white] (A1) at (0.85,2.18) {$4$};
		\node[text=white] (A1) at (1.85,2.18) {$3$};
		\node[text=black] (A1) at (2.85,2.18) {$2$};
		\node[text=black] (A1) at (3.85,2.18) {$1$};
		
		\node[text=black] (A1) at (0.85,3.18) {$1$};
		\node[text=black] (A1) at (1.85,3.18) {$2$};
		\node[text=white] (A1) at (2.85,3.18) {$3$};
		\node[text=white] (A1) at (3.85,3.18) {$4$};
		\end{tikzpicture}
	\label{subfig:USE}
	}
	\subfigure[RES]
	{
		\begin{tikzpicture}
			\foreach \i in {\xMin,...,\xMax} {
				\draw [very thin,gray] (\i,\yMin) -- (\i,\yMax)
				node [below] at (\i,\yMin) {};
			}
			\foreach \i in {\yMin,...,\yMax} {
				\draw [very thin,gray] (\xMin,\i) -- (\xMax,\i)
				node [left] at (\xMin,\i) {};
			}
		\draw[fill=white]  (0, 1) -- (1, 1) -- (1,0) -- (0,0) -- cycle;
		\draw[fill=darkgray]  (1, 1) -- (2, 1) -- (2,0) -- (1,0) -- cycle;
		\draw[fill=gray]  (2, 1) -- (3, 1) -- (3,0) -- (2,0) -- cycle;
		\draw[fill=lightgray]  (3, 1) -- (4, 1) -- (4,0) -- (3,0) -- cycle;
		
		\draw[fill=lightgray]  (0, 2) -- (1, 2) -- (1,1) -- (0,1) -- cycle;
		\draw[fill=gray]  (1, 2) -- (2, 2) -- (2,1) -- (1,1) -- cycle;
		\draw[fill=darkgray]  (2, 2) -- (3, 2) -- (3,1) -- (2,1) -- cycle;
		\draw[fill=white]  (3, 2) -- (4, 2) -- (4,1) -- (3,1) -- cycle;
		
		\draw[fill=white]  (0, 3) -- (1, 3) -- (1,2) -- (0,2) -- cycle;
		\draw[fill=lightgray]  (1, 3) -- (2, 3) -- (2,2) -- (1,2) -- cycle;
		\draw[fill=white]  (2, 3) -- (3, 3) -- (3,2) -- (2,2) -- cycle;
		\draw[fill=darkgray]  (3, 3) -- (4, 3) -- (4,2) -- (3,2) -- cycle;
		
		\draw[fill=darkgray]  (0, 4) -- (1, 4) -- (1,3) -- (0,3) -- cycle;
		\draw[fill=white]  (1, 4) -- (2, 4) -- (2,3) -- (1,3) -- cycle;
		\draw[fill=lightgray]  (2, 4) -- (3, 4) -- (3,3) -- (2,3) -- cycle;
		\draw[fill=gray]  (3, 4) -- (4, 4) -- (4,3) -- (3,3) -- cycle;
		
		\node[text=black] (A1) at (0.85,0.18) {$1$};
		\node[text=white] (A1) at (1.85,0.18) {$4$};
		\node[text=white] (A1) at (2.85,0.18) {$3$};
		\node[text=black] (A1) at (3.85,0.18) {$2$};
		
		\node[text=black] (A1) at (0.85,1.18) {$2$};
		\node[text=white] (A1) at (1.85,1.18) {$3$};
		\node[text=white] (A1) at (2.85,1.18) {$4$};
		\node[text=black] (A1) at (3.85,1.18) {$1$};
		
		\node[text=black] (A1) at (0.85,2.18) {$1$};
		\node[text=black] (A1) at (1.85,2.18) {$2$};
		\node[text=black] (A1) at (2.85,2.18) {$1$};
		\node[text=white] (A1) at (3.85,2.18) {$4$};
		
		\node[text=white] (A1) at (0.85,3.18) {$4$};
		\node[text=black] (A1) at (1.85,3.18) {$1$};
		\node[text=black] (A1) at (2.85,3.18) {$2$};
		\node[text=white] (A1) at (3.85,3.18) {$3$};
		\end{tikzpicture}
	\label{subfig:RES}
	}
	
	\caption{Different clocking Schemes in QCA} \label{fig:ClockingSchemes}
\end{figure}

The tile-based clocking leads to several proposals of clocking-schemes, which give a certain distribution of clock zones. Since they follow an uniform pattern they can be extended easily for every size of the circuit. In \ref{fig:ClockingSchemes} three clocking schemes are showed, each of them based on a different idea. Since information is only allowed in ascending clock order (except 4 to 1), the 2DDWave clocking scheme in figure \ref{subfig:2DD} only allows information to propagate in two directions, south and north \cite{2DD}. This simplicity allows no back propagation, prohibiting the placement of sequential circuits. Also it restricts gates in the scheme to have a maximum input size of two. The USE scheme \ref{subfig:USE} tackles the first problem by introducing clocking loops into the scheme, giving the possibility to place sequential circuits \cite{USE}. To tackle the second problem, the RES scheme \ref{subfig:RES} gives an opportunity to place gates of input size three. Since one tile is restricted to four adjacent cells of which one has to output the information of the cell, this gives the maximum input size allowed. This is especially important for the placement of majority-gates \cite{RES}. In QCA-technology they can be represented by only one tile, making it to a huge advantage over CMOS technology. This is further evaluated in the next subsection on gates.

\subsection{Gates}\label{sub:gates}

In this chapter a library of gates is introduced, which are later used in the placement and routing algorithms. Some of these gates are inherited from the QCA ONE library \cite{QCA_scl}, which is used as base for some works on placement and routing CITE.
The QCA ONE library proposes gates formed by one tile as well as gates formed by multiple tiles. A major drawback of this library is the prerequisite of a clocking scheme (USE) in order to form multiple tile gates. This restricts the underlying placement and routing algorithm in the clocking domain. Also manual changes of the standard cells clock zones, size or positioning is not allowed \cite{QCA_scl}, imposing the designer with even more restrictions. For this work, the standard cell library should only contain gates occupying one tile. Every other logic function is composed out of these standard cells. The tiles used are of the dimension $5 \times 5$, which means that all standard gates are reduced to this area.\\
%%%%%%Inverter
\begin{figure}
	\centering
	\subfigure[$45^{\circ}$ Inverter]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (A1) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{2.16}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.3, 0.36+\o) {$\neg i$};
			
		\end{tikzpicture} 
		\label{subfig:45Inverter}
	}
	\subfigure[Standard Inverter]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (A1) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\x{2.16}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.3, 0.36) {$\neg i$};
		\end{tikzpicture} 
		\label{subfig:StandardInverter}
	}
	\caption{Different QCA Inverter representations} \label{fig:QCAInverter}
\end{figure}
The first gate in the library is the inverter or NOT gate. The simplest implementation is shown in figure \ref{subfig:45Inverter}. It consists of two wire segments which are shifted by exactly one cell height, so that the polarization is transferred diagonally resulting in an inversion of the input \cite{Sasamal2020QuantumDotCA}. In order to get a more robust gate regarding disturbance, the C-shaped inverter shown in figure \ref{subfig:StandardInverter} is introduced. This gate is used as standard in many libraries and works CITE but it still has to be mentioned that this implementation is really prone to complex single electron faults \cite{SingelElectronFaults} and even common displacement faults \cite{Inverter_displacements}, suggesting the addition of an inverter leg resulting to a E-shaped gate structure. Nevertheless the C-shaped inverter gate is part of the QCA ONE library and is also selected as standard cell for this work.\\
%%%%%Majority gates
\begin{figure}
	\centering
	\subfigure[Rotated Majority gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_2$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw [fill = black](0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{1.44}
			\def\x{0}
			\node (I1) at (-0.3,0.36+\o) {$i_1$};
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			\node (I3) at (0.72 + \x + 0.3, 0.36+\o) {$i_3$};
			
			%One QCA-Cell
			\def\o{1.44}
			\def\x{1.44}
			\draw[rounded corners] (\x, 0+\o) rectangle (1.2*0.6 + \x, 1.2*0.6+\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36+\o) {$\langle i_1, i_2, i_3\rangle$};
			
		\end{tikzpicture} 
		\label{subfig:rotatedMaj}
	}
	\subfigure[Standard Majority Gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_2$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,1.7) {$i_1$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,-1.02) {$i_3$};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36) {$\langle i_1, i_2, i_3\rangle$};
		\end{tikzpicture} 
		\label{subfig:StandardMaj}
	}\\
	\subfigure[Standard AND Gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_1$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners, fill=black] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw [fill = white](0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw [fill = white](0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,1.7) {$0$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,-1.02) {$i_2$};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36) {$\langle 0, i_1, i_2\rangle$};
		\end{tikzpicture} 
		\label{subfig:StandardAnd}
	}
	\subfigure[Standard OR Gate]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			\node (I2) at (-0.3,0.36) {$i_1$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.6, 1.2*0.6) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6,0.9*0.6) circle (2*0.6mm);
			
			
			%One QCA-Cell
			\def\x{0.72}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			%One QCA-Cell
			\def\o{0.72}
			\def\x{0.72}
			\draw[rounded corners, fill=black] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = white](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = white](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,1.7) {$1$};
			
			
			%One QCA-Cell
			\def\o{-0.72}
			\def\x{0.72}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.6 + \x, 1.2*0.6 +\o) {};
			\draw (0.3*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.9*0.6+\x,0.3*0.6+\o) circle (2*0.6mm);
			\draw [fill = black](0.3*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.9*0.6+\o) circle (2*0.6mm);
			\node (I2) at (0.36 + \x,-1.02) {$i_2$};
			
			%One QCA-Cell
			\def\x{1.44}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.6 + \x, 1.2*0.6) {};
			
			\draw [fill = black] (0.3*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.9*0.6+\x,0.3*0.6) circle (2*0.6mm);
			\draw (0.3*0.6+\x,0.9*0.6) circle (2*0.6mm);
			\draw [fill = black] (0.9*0.6+\x,0.9*0.6) circle (2*0.6mm);
			
			\node (C1) at (0.72 + \x + 0.9, 0.36) {$\langle 0, i_1, i_2\rangle$};
		\end{tikzpicture} 
		\label{subfig:StandardOr}
	}
	\caption{The QCA Majority gate} \label{fig:QCAMaj}
\end{figure}
The next gate, which has to be investigated, is the majority gate, being the most important gate in QCA technology. Definition \ref{Def:majf} suggests that the implementation of this function in CMOS technology requires multiple AND and OR gates to be placed and routed. In QCA technology on the other hand a majority function can be represented by exactly one gate, making it one of the major advantages over CMOS technology. There are two main implementations of the majority gate. The rotated majority gate in figure \ref{subfig:rotatedMaj}, which is used in QCA ONE, and the $+$-majority gate \ref{subfig:StandardMaj}. Both of these implementations have their advantages and drawbacks. On the one hand the rotated majority gate exhibits sufficiently high degree of fault-tolerance against cell displacement or misalignment but has very poor degree of fault-tolerance against single cell omission or extra cell deposition \cite{majorityrotated}. The $+$-majority gate on the other hand is very prone to cell displacement but is also used as building block for AND and OR gates in most works. This means that the fabrication process for all these gates is very similar and since this work is more aimed to enhance the production of QCA circuits, the $+$-majority gate is chosen as standard gate for this work.\\
Following Definition \ref{Def:majf} the AND gate can be derived by fixing one input of the majority gate to logic $0$, while the OR gate is obtained by fixing one input to logic $1$. The resulting gates, which are also part of the standard gate library of this work are shown in figure \ref{subfig:StandardAnd}.\\

Another major topic regarding gates are wires. Until now only straight planar wires have been introduced. In order to distribute information on the 2D grid, provided by the tile based layout, also bent wires have to be introduced. They are depicted in Figure \ref{subfig:BentWire} and show a bend of 90 degrees. Given that all tiles can be rotated by $90^{\circ}$, $180^{\circ}$ and $270^{\circ}$ respectively a tile connected to a bent wire can be routed to each adjacent tile of a bent wire. Also since all gates introduced so far have a fan-out of one we need a fan-out node to multiply signals. This is done by adding a bent wire to a straight wire resulting in the fan-out shown in Figure \ref{subfig:FanoutWire}.\\
%%%%Wire crossing
\begin{figure}
	\centering
	\subfigure[Coplanar wire crossing]
	{
		\centering
		\begin{tikzpicture}
			%One QCA-Cell
			%\node (I2) at (-0.3,0.36) {$i$};
			\draw[rounded corners] (0, 0) rectangle (1.2*0.5, 1.2*0.5) [label=north:$v_7$]{};
			
			\draw [fill = black](0.3*0.5,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black](0.9*0.5,0.9*0.5) circle (2*0.5mm);
			
			
			%One QCA-Cell
			\def\x{0.6}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.5 + \x, 1.2*0.5) {};
			
			\draw [fill = black] (0.3*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5+\x,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black] (0.9*0.5+\x,0.9*0.5) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{0}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw [fill = black](0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw (0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\x{1.8}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.5 + \x, 1.2*0.5) {};
			
			\draw [fill = black] (0.3*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5+\x,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black] (0.9*0.5+\x,0.9*0.5) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\x{2.4}
			\draw[rounded corners] (\x, 0) rectangle (1.2*0.5 + \x, 1.2*0.5) {};
			
			\draw [fill = black] (0.3*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.9*0.5+\x,0.3*0.5) circle (2*0.5mm);
			\draw (0.3*0.5+\x,0.9*0.5) circle (2*0.5mm);
			\draw [fill = black] (0.9*0.5+\x,0.9*0.5) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{0.6}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw (0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw [fill = black](0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{1.2}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw [fill = black](0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw (0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{-0.6}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw (0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw [fill = black](0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
			
			%One QCA-Cell
			\def\o{-1.2}
			\def\x{1.2}
			\draw[rounded corners] (\x, 0 + \o) rectangle (1.2*0.5 + \x, 1.2*0.5 +\o) {};
			\draw [fill = black](0.6*0.5+\x,0.3*0.5+\o - 0.025) circle (2*0.5mm);
			\draw (0.9*0.5+\x + 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw (0.3*0.5+\x - 0.025,0.6*0.5+\o) circle (2*0.5mm);
			\draw [fill = black](0.6*0.5+\x,0.9*0.5+\o + 0.025) circle (2*0.5mm);
		\end{tikzpicture} 
		\label{subfig:CoplanarWire}
	}
	\subfigure[Multi-layer wire crossing]
	{
		\centering
		\includegraphics[scale=0.25]{wire_crossing}
		\label{subfig:mlwirecrossing}
	}
	
	\caption{Different wire QCA wire crossing implementations} 
\end{figure}
The last special case of wires are crossing cases. By rotating the cells of one wire string by $45^{\circ}$ the rotated cells don't have crosstalk with non-rotated cells \cite{Inverter_displacements} as shown in figure \ref{subfig:CoplanarWire}. This solution is very handy because it supports the planar structure of the circuit and is therefore called \textit{coplanar crossover}. Further the possibility of multi-layer QCA has been investigated and found especially useful in the case of wire crossings. To use this, one wire string is raised to an additional higher layer, which is connected with a vertical interconnect as in figure \ref{subfig:mlwirecrossing}. The signal transmission in the vertical stacked cells works just as in horizontal direction. To impede any crosstalk between the wire strings two intermediate layers of cells are used in vertical direction. Theoretically the added layer cannot only be used as wire but since the signal distribution works just as in the ground layer also gates can be placed in these multi-layers. Simulations have shown that coplanar crossovers reduce the coupling between the horizontal string segments significantly. This makes the horizontal interconnect very sensitive to crosstalk and therefore highly prone to cell displacements. Multi-layer circuits on the other hand show a high robustness and therefore are used as standard in this library. In the gate $5 \times 5$ representation of the multi-layer interconnect, the raised wire string is described with a $\times$, while the vertical layers are described with a circle. In Figure \ref{fig:StandardCellLibrary} all gates used in this work are summarized.

\begin{figure}
	\centering
	\subfigure[INV]
	{
		\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
			\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
			
			\foreach \x/\y in {0.9/0.9, 0.9/0.45, 1.35/0.45, 0.45/0.45, 1.35/0, 0.45/0, 0.9/-0.45, 0.9/-0.9}
			{
				\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
				\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
				\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
				\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
				\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
			}
		\end{tikzpicture}
	}
\subfigure[MAJ]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0, 1.35/0, 1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}
\subfigure[AND]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0, 1.35/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
		\foreach \x/\y in {1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=black] (\x, 0 + \y) rectangle 	(1.2/3 + \x, 1.2/3 + \y){};
			\draw [fill=white](0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw [fill=white](0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}
\subfigure[OR]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0, 1.35/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
		\foreach \x/\y in {1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=black] (\x, 0 + \y) rectangle 	(1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw [fill=white](0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw [fill=white](0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}\\
\subfigure[Wire]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
}
\subfigure[Bent wire]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0/0, 0.45/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
	\label{subfig:BentWire}
}
\subfigure[Fanout]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0.9/0.9, 0.9/0.45, 0.9/0, 0.9/-0.45, 0.9/-0.9, 0/0, 0.45/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
	\end{tikzpicture}
	\label{subfig:FanoutWire}
}
\subfigure[Wire crossing]
{
	\begin{tikzpicture}[rotate=90, scale=1.1, every node/.style={scale=1.2}]
		\draw[rounded corners] (-0.05, -0.1 - 0.85) rectangle (2.3-0.05, 2.3-0.1 - 0.85){};
		
		\foreach \x/\y in {0/0, 0.45/0, 1.35/0, 1.8/0}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (0.3/3+ \x,0.3/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.3/3+ \y) circle (0.65mm);
			\draw (0.3/3+ \x,0.9/3 + \y) circle (0.65mm);
			\draw (0.9/3+ \x,0.9/3 + \y) circle (0.65mm);
		}
		\foreach \x/\y in {0.9/-0.45, 0.9/0, 0.9/0.45}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle 	(1.2/3 + \x, 1.2/3 + \y){};
			\node (X) at (\x + 0.5*0.45- 0.025, \y + 0.5*0.45 - 0.025) {$\times$};
			
		}
		\foreach \x/\y in {0.9/-0.9, 0.9/0.9}
		{
			\draw[rounded corners = 0.3mm, fill=lightgray] (\x, 0 + \y) rectangle (1.2/3 + \x, 1.2/3 + \y){};
			\draw (\x + 0.5*0.45- 0.025, \y + 0.5*0.45 - 0.025) circle (1.4mm){};
			
		}
	\end{tikzpicture}
}
	\caption{QCA Standard Library}\label{fig:StandardCellLibrary}
\end{figure}

\subsubsection{Latches and Registers}\label{subsec:latchesandregisters}
Looking at a sequential circuit, it is the marriage of a combinational logic part and registers. When treating the combinational logic as blackbox, the outputs of it are storing the newly computed information into the registers and in the next cycle this information can be reused by connecting the registers again to the inputs of the combinational logic. This introduces a back-loop property, describing a signal propagating through combinational logic before getting stored and stabilized by a register and being reused again. This back-looping represents the key property of sequential circuits.
Assuming that cominational logic can be implemented in QCA, registers or rather storage elements in general leave to be discussed. As already mentioned their task is to stabilize and store information which is then looped back via wires. To get a better understanding of how they can be implemented in QCA, first their main characteristics have to be derived from the well-known CMOS technology. Due to the already shown basic differences in signal propagation and clocking between the two technology domains, it will become clear that the implementation of latches and registers also has to be rethought from scratch.

\begin{figure}
	\centering
	\begin{circuitikz}[american] \draw
		(1,0) node[not port] (not1) {}
		(1,-2) node[not port, rotate = 180] (not2) {}
		(-1,0) -- (0, 0)
		(0,0) -- (not1.in)
		(not1.out) -- (2, 0)
		(2, 0) -- (3, 0)
		(2, 0) -- (2, -2)
		(2, -2) -- (not2.in)
		(not2.out) -- (0, -2)
		(0, -2) -- (0, 0)
		
		(0.5,0) node [anchor=west] {$1$}
		(1.5,-2) node [anchor=east] {$2$}
		(-2, 0) node [anchor=west] {$in$}
		(4, 0) node [anchor=east] {$out$}
		(-2, -1) node [anchor=west] {$V_{o1}=V_{i2}$}
		(4, -1) node [anchor=east] {$V_{o2}=V_{i1}$}
		;
	\end{circuitikz}
	\caption{Eccles-Jordan-Flip-Flop}\label{fig:EJFF}
\end{figure}

The simplest storage element in CMOS, which can store one bit, is the so called EcclesJordan \text{flip-flop} (FF). It is formed by connecting the output of one inverter to the input of another inverter and vice versa. Therefore the logic level is propagated from one inverter stage to the other, while the same value is held in it. Due to its simplicity, a high voltage shift is needed in order to change its stored value making the FF really sluggish.

Also the direct connection of the input and output makes their voltage levels highly dependent on each other, which can be interpreted as noisy behavior, also referred to as \text{transparency} \cite{hawkins2012cmos}. To circumvent errors caused by the transparent behavior in the transition region, the input voltage needs to be really stable. In order to receive more robust storage elements, more sophisticated ideas were implemented while preserving the general idea introduced by the EJ-FF.

By replacing the inverters in a EJ-FF with NOR gates, the transparency gets reduced and two inputs a set $S$ and a reset $R$ are introduced leading to four possible input combinations and clear states. When both $S=0$ and $R=0$, the current value is latched and the storage element is in the hold state. By holding $R=0$ and changing $S=1$, the latch output is forced to $Q=1$, called the set state. Reversing both inputs to $R=1$ and $S=0$ leads to the reset state where the latch output is $Q=0$. Furthermore with $S, R = 1$, the latch value is unstable and therefore we get an undefined state, prohibiting this input combination. Based on its behavior this element is called \textit{Set-Reset-Latch} (SR-Latch). 

\begin{figure}
	\centering
	\begin{minipage}{0.35\textwidth}
		\begin{circuitikz}[american] \draw
			(0,2) node[nor port] (NOR1) {}
			(1,2) node[anchor=east] {Q}
			(1,0) node[anchor=east] {$\overline{Q}$}
			(0,0) node[nor port] (NOR2) {}
			(NOR1.in 1) node[anchor=east] {R}
			(NOR2.in 2) node[anchor=east] {S}
			(NOR1.out) -- ++(0,-0.5) -- ($(NOR2.in 1) +(0,0.5)$) -- (NOR2.in 1)
			(NOR2.out) -- ++(0,+0.5) -- ($(NOR1.in 2) +(0,-0.5)$)--(NOR1.in 2)
			;
		\end{circuitikz}
	\end{minipage}
	\begin{minipage}{0.35\textwidth}
		\begin{tabular}{| c | c | c | c |}
			\hline
			\textbf{S} & \textbf{R} & \textbf{$Q_{next}$} & \textbf{State}\\
			\hline
			0 & 0 & Q & hold state\\
			\hline
			0 & 1 & 0 & reset\\
			\hline
			1 & 0 & 1 & set\\
			\hline
			1 & 1 & X & undefined state\\
			\hline
		\end{tabular}
	\end{minipage}	
	\caption{SR-Latch}\label{fig:SR-Latch}
\end{figure}

Because in QCA we only discuss synchronous logic, we also need to make this latch synchronous by clocking the Set and Reset inputs resulting in a gated SR-Latch. To eliminate the undefined state, the set and inverted reset inputs are connected together forming the D-Latch. Now a value is held when the clock $clk=0$ and the D-latch is propagating the $D$ input value, when $clk=1$. Since transparency is still present a edge-triggered D-FF is formed by connecting two D-latches to a master-slave D-flip-flop producing only stable outputs.\\
The goal of a storage element in QCA is to have all the properties of a D-FF. In the QCA ONE library an effort was made to translate the D-FF into QCA by just replacing the CMOS gates and wires with the corresponding QCA gates. But since clocking plays an important role in the functionality of storage elements and the clocking has some major differences from QCA to CMOS as already observed in \ref{subsec:clocking}, the sense of purpose is questionable.\\
This means that storage elements should be completely rethought in the QCA domain. To create a QCA element which is able to store one bit the solution is rather simple. Since every tile is clocked on its own, a simple latch can be formed by a wire segment held in the hold phase of the clocking. In Figure !! such a wire segment is depicted. It is still adjacent to one ascending and one descending clock number (mod $N_{clk}$). The storage property is reached by extending the hold phase a the required number of clock cycles \cite{Walter}. 
%It can also be observed that in the hold phase a stable polarization is already implied, so that such a wire segment can not only be referred to as latch but as flip-flop. 
Because this implementation needs a different clock generator for every latch it is not sure if it is possible to implement. Though it can be shown that the same properties can be achieved by placing buffering wire segments instead of the introduced wire-latch. For every clock cycle the hold phase would be extended in the wire-FF, four adjacent wire segments are added delaying the information arrival by exactly the same time. Since wires have to be used to route the loops created by sequential circuits this idea is implemented for this work and explained more accurate in the next chapters.
%D-latch can be used to delay time by the circuit frequency
\\
\begin{figure}
	\centering
	\begin{minipage}{0.5\textwidth}
		\begin{circuitikz}[american] \draw
			% Draw and gates
			(0,2) node[and port] (and1) {}
			(0,0) node[and port] (and2) {}
			
			% Draw nor gates
			(and1.out) -- ++(0.25,0) node
			[
			nor port,
			anchor=in 1
			] (nor1) {}
			
			(and2.out) -- ++(0.25,0) node
			[
			nor port,
			anchor=in 2
			] (nor2) {}
			
			(nor1.in 2) -| ++ (-0.3,-0.25) -- ++(2,-0.5) coordinate(a) |- (nor2.out)
			(nor2.in 1) -| ++ (-0.3,0.25) -- ++(2,0.5) |- (nor1.out)
			
			% Clock
			(and1.in 2) -- (and2.in 1)node[midway](clk){}
			(clk.center) -- ++(-1.25,0) node[left]{Clk}
			
			% Output labels
			(nor1.out -| a) -- ++(0.75,0) node[right]{$Q$}
			(nor2.out -| a) -- ++(0.75,0) node[right]{$\overline{Q}$}
			
			(and2.in 2) -- ++(-1.25,0) coordinate(a2) node[left=0.1cm]{D}
			
			% Not port
			(-1.9,0.2) node
			[
			not port,
			rotate=90,
			scale=0.5,
			](not) {}
			
			(not.in) |- (a2) (not.out) |- (and1.in 1)  
;
		\end{circuitikz}
	\end{minipage}
	\begin{minipage}{0.4\textwidth}
		\begin{tabular}{| c | c | c | c |}
			\hline
			\textbf{clk} & \textbf{D} & $Q_{next}$ & \textbf{State}\\
			\hline
			0 & 0 & * & hold state\\
			\hline
			0 & 1 & 0 & propagate\\
			\hline
			1 & 0 & 1 & propagate\\
		
			\hline
		\end{tabular}
	\end{minipage}	
	\caption{D-Latch}\label{fig:D-Latch}
\end{figure}

\section{P\&R problem} \label{sec:PR}

As seen in the last sections of this chapter placement and routing are strongly related to the clocking inside the QCA domain. In this section the denotation and constraints of placement and routing in the QCA domain are introduced. The P\&R problem evolves from a grid enabling tile based design in conjunction with a logic network.

\begin{definition}
	A \textit{layout} is defined by a $w \times h$ grid $\Gamma_{w, h}$ and a graph $G(V, E)$, which is placed on the grid. Every \textit{tile} of the layout can be accessed via its $x$ and $y$ coordinates. The set of tiles is denoted as $T$ with $t = (x, y) \in T$. For any vertex of the graph $v(x, y)$ is restricted to the boundaries $x < w$ and $y < h$. For edges $\{(x, y), (x^*, y^*)\}$ it holds $\vert x-x^*\vert+\vert y-y^*\vert = 1, 0 \leq x, x^* \leq w, 0 \leq y, y^* \leq h$.
\end{definition}

\begin{definition}
	A \textit{gate-level} layout describes a layout grid in combination with a logic network $N = (\Lambda, I, \Sigma, O)$. Besides the already known mapping \textit{placement} $p$, which assigns nodes to tiles, there are two additional mappings. The \textit{routing} $r$, which assigns logic network signals to layout paths (connected tiles) and a \textit{clocking} $c$ assigning clock numbers to tiles. The gate-level layout is therefore described as $L = (\Gamma, N, p, r, c)$.\\
	Further, nodes placed on the gate-layout are referred to as \textit{gates}. Two tiles $t_i = (x_i, y_i)$ and $t_j = (x_j, y_j)$ where $\vert x_i-x_j\vert+\vert y_i-y_j\vert = 1$ are called \textit{adjacent}. A path, which is wired through adjacent tiles is called \textit{wire}. In this context one tile corresponds to a \textit{wire segment}. If neither a gate nor a wire segment is placed on a tile, it is empty. It follows that a layout with only empty tiles is also empty. A layout is said to be S-clocked if it follows a clocking scheme S. Otherwise it is irregularly clocked. Moreover an adjacent tile of a tile $t \in T$, where $T$ is the set of all tiles, is incoming $t^-$ if $c(t) - c(t^-) \mod{clk} = 1$. This means that the incoming tile is able to forward information to the viewed tile according to pipelined clocking. For outgoing tiles $t^+$ it holds $c(t^+) - c(t) \mod{clk} = 1$ accordingly. For QCA it was already stated that the clock number $clk = 4$.\\
\end{definition}

From this definition we can outline the difficulty of placing and routing a logic network onto a two dimensional grid, with exception of wire crossings, which however are really costly and therefore should be minimized. One major challenge for P\&R algorithms is the signal synchronization, which results the strong dependency of clocking and signal distribution. As already pointed out, for every signal path it has to hold true that information can only propagate from a tile with clocking number $i$ to an outgoing tile with clocking number $(i+1 \mod clk)$. This property is called the \textit{local synchronization constraint}. The existence of possible signal paths can be assured by using predefined clocking schemes, but however can comprise some constraints. Further the \textit{global synchronization constraint} states that every two signal paths leading to the same tile need to pass the same amount of tiles starting at their primary input. Since this constraint has to hold true for every gate the complexity increases rapidly with growing network sizes. Therefore the combination of all these challenges forms a P\&R problem, which is commonly accepted to be $\mathcal{NP}$-hard \cite{NP-hard}. \\
After reaching a gate-level layout still a technology has to be mapped onto it. For this work the in subsection \ref{sub:gates} proposed standard library is used for the mapping. Although the definitions in this work are held quite generic because they are based on the book \cite{Walter}, defining the P\&R problem for the field-coupled nanotechnologies domain. This means that for example a change of clock to $clk = 3$ also allows a placement and routing for \textit{Nanomagnet Logic} (NML). Even though the algorithm in this work is designed only for QCA, the ideas may also be derived for other FCN technologies.